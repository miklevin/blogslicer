---

title: Title


keywords: fastai
sidebar: home_sidebar



nb_path: "00_core.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 00_core.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-05-01-post-20.md">FILE: ../pythonically/_posts/2022-05-01-post-20.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-05-01-post-20.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Pushing Blogslicer to PyPI (From Jupyter Notebook)&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: pushing-blogslicer-to-pypi-from-jupyter-notebook
permalink: /blog/pushing-blogslicer-to-pypi-from-jupyter-notebook/
---

I hate smart quotes. I don&#39;t think they&#39;re good for SEO (search engine
optimization). I adhere to a principle called &#34;The Weakest Link In The Chain&#34;.
Unfortunately such a good metaphor has been tarnished by that awful game show
of the same name years back, but the concept will last longer than memories of
that atrocity, so I will keep using it.

Every Little Thing gets done, or ELTgd, as I&#39;m currently acronym&#39;ing it. I get
smart quotes when I copy/paste out of other more word-processing oriented
software into vim where I blog. There&#39;s many ways I could address fixing this,
but I have a release script that slices &amp; dices my single-long-page text files
that I blog in (one journal for life, one journal per website) into separate,
individually optimized pages.

I actually don&#39;t sweat the optimization too much. I let my confidence that I
will gradually massage and organize sites over time allow me to write at
full-speed. And I do write fast. My typing speed isn&#39;t really that fast.
Neither is my thinking speed. It&#39;s just that both are decent speed and in sync
with each other, so I write just a bit slower than I can talk, and that means I
can publish a lot... a whole lot, and so I do... now... as a result of
operation ELTgd.

This particular blog post on Pythonic Ally is to see how quickly I can get a
package called &#34;dumbquotes&#34; into PyPi. For you see, the next step in my
blogslicer (also soon to be in PyPI) is to strip out smart quotes, and I don&#39;t
see why that can&#39;t and shouldn&#39;t be a separate package of potentially broader
use than blogslicer if made separate.

Okay, so before I do dumbquotes, I want to get blogslicer into PyPi.org. I use
a developer tool called nbdev from the illustrious Australian and all around
cool guy, Jeremy Howard of Fast.ai. If you&#39;re into Machine Learning, I suggest
all his stuff over the competing Google TensorFlow because with TensorFlow, all
things lead to the vendor-trap. But with fast.ai, all roads lead to generic
GPU-based less vendor dependt goodness.

But I digress. I&#39;ve already refined blogslicer a bit in Github. Making it pip
installable should be a breeze. 1, 2, 3... 1?

Quickly edit the index.ipynb which gets turned into the README.md which becomes
the Github repo homepage documentation. Important! Okay, done but my trick for
switching between Notebook mode and command-line mode arguments is causing an
error on:

```python
#hide
from blogslicer.core import *
```

So I&#39;m just commenting out that import and tabling the issue for now. Next?
Look at my release system. Even though I don&#39;t NEED to bump the version, that
is usually my next step. And I&#39;m doing everything manually first. Then I&#39;ll put
it into my release script.

```bash
$ nbdev_bump_version
Old version: 0.0.1
New version: 0.0.2
```

Okay, that went off without a hitch. Next!

```bash
$ nbdev_build_docs
```

...oops! A glorious error, probably related to the above problem importing
blogslicer.core into the index.ipynb. nbdev has its weirdness. It&#39;ll just be a
matter of practice, but I&#39;ll skip it for now. Next!

```bash
$ nbdev_build_lib
Converted 00_core.ipynb.
Converted index.ipynb.
```

Okay, that ran without a hitch and that&#39;s the important one. Next!

```bash
nbdev_clean_nbs
```

No output, but that means it ran well. Always a good idea before:

```bash
git commit -am &#34;Preparing for first PyPI release&#34;
(output removed)
(py310) ubuntu@LunderVand:/mnt/c/Users/mikle/github/blogslicer$ git push
(output removed)
```

Next!

```bash
$ mkdir dist
$ python3 -m build
(lots of output removed)
Successfully built blogslicer-0.0.2.tar.gz and blogslicer-0.0.2-py3-none-any.whl
```

And finally...

```bash
$ twine upload dist/*
Uploading distributions to https://upload.pypi.org/legacy/
Uploading blogslicer-0.0.2-py3-none-any.whl
100% ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 12.6/12.6 kB • 00:00 • 461.3 kB/s
Uploading blogslicer-0.0.2.tar.gz
100% ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 13.7/13.7 kB • 00:00 • 718.8 kB/s

View at:
https://pypi.org/project/blogslicer/0.0.2/
```

Success! But without the documentation successfully built, both the Github repo
page and PyPi package page contain a generic nbdev template. Ugh! That can&#39;t
stand. Okay, diagnose that quickly. No rabbit holes!

Okay, I was able to uncomment the index.ipynb package import by changing the
Jupyter environment check to control where the arguments come from like so:

```python
if hasattr(__builtins__, &#34;__IPYTHON__&#34;) or __name__ != &#39;__main__&#39;:
    from IPython.display import display, Markdown

    h1 = lambda text: display(Markdown(f&#34;# {text}&#34;))
    h2 = lambda text: display(Markdown(f&#34;## {text}&#34;))
    h3 = lambda text: display(Markdown(f&#34;### {text}&#34;))

    folder_name = &#34;../pythonically&#34;
    blog_title = &#34;Pythonic Ally Blog&#34;
    blog_slug = &#34;blog&#34;
    author = &#34;Mike Levin&#34;
else:
    h1 = lambda text: print(f&#34;# {text}&#34;)
    h2 = lambda text: print(f&#34;## {text}&#34;)
    h3 = lambda text: print(f&#34;## {text}&#34;)

    aparser = argparse.ArgumentParser()
    add_arg = aparser.add_argument
    add_arg(&#34;-p&#34;, &#34;--path&#34;, required=True)
    add_arg(&#34;-t&#34;, &#34;--title&#34;, required=True)
    add_arg(&#34;-s&#34;, &#34;--slug&#34;, required=True)
    add_arg(&#34;-a&#34;, &#34;--author&#34;, required=True)
    args = aparser.parse_args()

    folder_name = args.path
    blog_title = args.title
    blog_slug = args.slug
    author = args.author
```

I know it worked without breaking the command-line (using &#34;python&#34; in the
command) input because you&#39;re reading this. And so I&#39;ve finally completed my
pattern for creating packages in Jupyter Notebooks (really, JupyterLab) and
having them also work as parameterized command-line tools releasable into PyPI.
I still have a little work to go to make it work without the python interpreter
prefix. I&#39;ve got some research to do on how pip installing results in
CLI-runnable commands.

So now onto dumb-quotes. I&#39;m going to hold off on putting the actual PyPI
release into my everyday frequently used blog release script. I thing that may
cause more harm than good. But definitely a topic for later is bringing the
PyPI package up-to-date with my fast-and-furious daily code tweaking.

Okay, so one more time, but from scratch (blogslicer was already well
underway).









</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-05-01-post-19.md">FILE: ../pythonically/_posts/2022-05-01-post-19.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-05-01-post-19.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Sharpening My Prev/Next Arrows&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: sharpening-my-prev-next-arrows
permalink: /blog/sharpening-my-prev-next-arrows/
---

It turned out that what was &#34;most broken&#34; in my opinion was the formatting of
the previous/next arrows. I put so much effort into just having them at all
over the past day that it&#39;d be silly to stop before I tweaked them to an
acceptable point. You&#39;re probably looking at them now. Makes you want to click
them, doesn&#39;t it? Well, here&#39;s the secret sauce.

Here&#39;s the style.scss

    ---
    ---

    @import &#39;jekyll-theme-hacker&#39;;

    .spacer {
        padding-top: 1.5em;
        padding-bottom: 1.5em;
    }

    .post-nav {
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
    }

    .post-nav-prev {
        text-align: left;
    }

    .post-nav-next {
        text-align: right;
    }

And here&#39;s the post.html. I use a very old-school non-breaking-space trick
here, but it works super-well. There&#39;s some flexbox wrangling here and its
flex sub-command I&#39;m still getting a handle on. I may make it more elegant in
the future, but the way it displays certainly looks elegant.

And of course the other tired old trick of yet-another-div because padding or
whatever doesn&#39;t work correctly on the inner one.

...opps, apparently I can&#39;t show you that until I learn about neutralizing and
escaping Jekyll blog post Liquid directives better.

Oh, and the reason vim is better than emacs is because



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-05-01-post-18.md">FILE: ../pythonically/_posts/2022-05-01-post-18.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-05-01-post-18.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Making YouTube Embeds 100% Width But Fixed Aspect Ratio Height&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: making-youtube-embeds-100-width-but-fixed-aspect-ratio-height
permalink: /blog/making-youtube-embeds-100-width-but-fixed-aspect-ratio-height/
---

There&#39;s a number of potential directions to go now. The temptation is to start
doing stupid SEO-tricks at the Pipulate.com site. Specifically, it&#39;s time to
spin through my &gt;1000 YouTube videos from over the years and spit out static
wrapper-pages for them. Or more specifiably, spit out a single journal-format
page that has the slicer-token, date, video title as page title and video
description as page content, and of course the YouTube embed code. So then I
will have a series of pages that you could next, next, next through using the
prev/next arrows. And I sort and categorize the videos to make topical
groupings somehow. I may bring back the Jekyll blog post tags which I edited
out of posts.html.

That&#39;s the temptation, anyhow. But the reality is that before I do such an
indulgent project, I should really finish the last few bits of obvious Jekyll
housekeeping that call out to me. I want to externalize the Google Analytics
code so that the default.html is smaller. There&#39;s no reason to have the
specific GA implementation hardwired into default.html. Okay, so it&#39;s education
time. I really ought to install Jekyll locally at some point to have even more
hands-on, but that&#39;s the messy tech liability stuff I&#39;m trying to avoid. If
you&#39;re going to enjoy the magic of hand-waving, Github Pages is exactly where
to do it. So keep my life simple and just find the magic gestures.

There&#39;s this [tutorial page on what Jekyll layouts are](https://jekyllrb.com/docs/step-by-step/04-layouts/)
that shows even default.html can have those Liquid curly braces in them. I&#39;m
using something like that for the youtubePlayer.html include. So right off, I&#39;m
going to change the size of that thing to be 100% width. Seeing YouTube embeds
create a horizontal scroll in mobile has been bugging me. So start with that
and make a tiny assertion of control...

Before

```html
&lt;iframe src=&#34;https://www.youtube.com/embed/{{ include.id }}&#34;
    width=&#34;560&#34;
    height=&#34;315&#34;
    frameborder=&#34;0&#34;
    allowfullscreen&gt;
&lt;/iframe&gt;
```

After

```html
&lt;iframe src=&#34;https://www.youtube.com/embed/{{ include.id }}&#34;
    style=&#34;width: 100%;&#34;
    frameborder=&#34;0&#34;
    allowfullscreen&gt;
&lt;/iframe&gt;
```

@g

...yep, success! YouTube videos are now attractively screen-width, even if that
screen is a tiny mobile phone. Oops, but it&#39;s height is squashed. Research
that...

Top-10 answers on the board... survey says!
[Jim Fisher has the answer](https://jameshfisher.com/2017/08/30/how-do-i-make-a-full-width-iframe/)
the answer being use a container div with relative positioning and a 56.25% for
padding top. Go figure! Here&#39;s the code for \_layouts/youtubePlayer.html that
works for me in Edge mobile and Chrome desktop (and probably everywhere else
even semi-modern):

```html
&lt;div&gt;
  &lt;div style=&#34;position:relative;padding-top:56.25%;&#34;&gt;
    &lt;iframe src=&#34;https://www.youtube.com/embed/{{ include.id }}&#34; frameborder=&#34;0&#34; allowfullscreen
      style=&#34;position:absolute;top:0;left:0;width:100%;height:100%;&#34;&gt;&lt;/iframe&gt;
  &lt;/div&gt;
&lt;/div&gt;
```

BAM!


</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-05-01-post-17.md">FILE: ../pythonically/_posts/2022-05-01-post-17.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-05-01-post-17.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Disabling Github CI nbdev_install_git_hooks&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: disabling-github-ci-nbdev-install-git-hooks
permalink: /blog/disabling-github-ci-nbdev-install-git-hooks/
---

I just updated my release script using a bash loop. That was very satisfying. I
guess I question now how much these next steps on the blogslicer project belong
here on Pythonic Ally. All this Github Pages Jekyll stuff... not really even
sure where it belongs. Maybe SEO? I&#39;m using MikeLevinSEO.com for the mlseo repo
page. Maybe Mike-Levin.com? Or just on plain MikeLev.in. Anyway, I can sort
that out as I go. Don&#39;t lose momentum is the important thing.  And on the front
of not losing momentum, it&#39;s time to ask my standard questions:

1. What&#39;s most broken?
2. Where do I get the biggest bang for the buck?
3. What plates need to be spun?

Oh! USING mlseo is the process of Pipulating. And so it&#39;s just about time to
bring pipulate.com back to life applying everything form mlseo and creating
that righteous feedback loop to push forward the usefulness of mlseo.

Okay, so every time I push to pipulate or blogslicer, I get a Github CI Run
failed email. nbdev enables Github continuous integration (CI) with a
easy-to-run script after you nbdev_new so long as your repo is public. It&#39;s
tempting to do, but whatever it does causes errors on every push, so I found
this page to [disable Github CI](https://docs.github.com/en/actions/managing-workflow-runs/disabling-and-enabling-a-workflow)
I followed the instructions and just deleted all my &#34;Run Failed&#34; CI emails. Now
I&#39;m running my release script again...

And it worked! Wow, yeah, this is not Pythonic Ally at all anymore. Neither is
it the type of thing I really want to put on the Linux, Python, vim &amp; git site.
No, this is feeling a lot like what SHOULD be on mikelevinseo.com BEFORE I
turned it into the repo page for mlseo. I may have to rethink that.

But don&#39;t lose momentum. Keep going! Every Little Project Gets Done... Next!


</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-05-01-post-16.md">FILE: ../pythonically/_posts/2022-05-01-post-16.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-05-01-post-16.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Writing a Bash Loop Script for Jekyll&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: writing-a-bash-loop-script-for-jekyll
permalink: /blog/writing-a-bash-loop-script-for-jekyll/
---

Editing 10 sites at once that are all actually in-play requires editing a lot
of files at once, quite often identical. So long as they are identical, I
should really centralize them. I can always break them into 10 different
individually managed files anytime I want. But until then, cross-cutting
changes will be a breeze. I&#39;m already using a &#34;helper&#34; repo for this purpose...
almost. I just need to carry through on the concept. Every little project gets
done! 1, 2, 3... 1?

List the files you&#39;ll be doing this with and put a copy in place.

- \_config.yml (will break much of MikeLev.in, but fix as you go)
- \_includes/youtubePlayer.html
- \_layouts/post.html
- assets/css/styles.scss

I&#39;ll even be able to do \_layouts/default.html once I understand how to break
out the Google Analytics ID with an include similar to the way I do the YouTube
wrapper, but it&#39;s one more layer lower in the rendering process so I have to
think it through. Go ahead with those other ones and keep a sharp eye om
MikeLev.in because it&#39;s so different from the others.

```bash
for SITE in MikeLevin pythonically whatsametafor linuxpythonvimgit mikeateleven tardigradecircus removablefinger mike-levin lundervand pipulate guerillatech
do
    rm ./$SITE/_posts/*
    cp ./helpers/_config.yml ./$SITE/
    cp ./helpers/style.scss ./$SITE/assets/css/
    cp ./helpers/post.html ./$SITE/_layouts/
    cp ./helpers/youtubePlayer.html ./$SITE/_includes/
done
```

Okay wow, that&#39;ll change things. Think! Ready, fire, aim! Why not? It&#39;s Sunday
morning and I have time to fix anything that breaks. Here&#39;s my entire current
release script, which I call gall.sh... LOL! I&#39;ve got some gall.

```bash
#    _     _           _
#  _| |__ | | __ _ ___| |_
# (_) &#39;_ \| |/ _` / __| __|
#  _| |_) | | (_| \__ \ |_
# (_)_.__/|_|\__,_|___/\__|

clear

for SITE in MikeLevin pythonically linuxpythonvimgit mikeateleven tardigradecircus removablefinger mike-levin lundervand pipulate whatsametafor guerillatech
do
    rm ./$SITE/_posts/*
    cp ./helpers/_config.yml ./$SITE/
    cp ./helpers/style.scss ./$SITE/assets/css/
    cp ./helpers/post.html ./$SITE/_layouts/
    cp ./helpers/youtubePlayer.html ./$SITE/_includes/
done

figlet slicing blogs...
cd blogslicer
nbdev_clean_nbs
nbdev_build_lib
git commit -am &#34;Updating all&#34;
git push

python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../MikeLevin&#34; -t &#34;Mike Levin&#39;s Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../pythonically&#34; -t &#34;Pythonic Ally Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../whatsametafor&#34; -t &#34;What&#39;s A Meta For Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../linuxpythonvimgit&#34; -t &#34;Linux, Python, vim &amp; git Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../mikeateleven&#34; -t &#34;Mike&#39;s At Eleven Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../tardigradecircus&#34; -t &#34;Tardigrade Circus Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../removablefinger&#34; -t &#34;Removable Finger Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../mike-levin&#34; -t &#34;Mike-Levin.com Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../lundervand&#34; -t &#34;Lunervand Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../pipulate&#34; -t &#34;Pipulate Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../guerillatech&#34; -t &#34;Guerilla Tech Blog&#34; -s &#34;blog&#34;
cd ..

figlet vim
cp ~/.vimrc ./vim/
cd ./vim
git commit -am &#34;Updating all&#34;
git push
cd ..

figlet helpers
cp ./all.sh ./helpers/
cp ./gall.sh ./helpers/
cp ./defaults.sh ./helpers/
cp ./homepages.sh ./helpers/
cp ./styles.sh ./helpers/
cd helpers
git commit -am &#34;Updating all&#34;
git push
cd ..

figlet journal
cd journal
git commit -am &#34;Updating all&#34;
git push
cd ..

figlet mikelevinseo -w 120
cd mlseo
jupyter nbconvert --to markdown index.ipynb
sed -i -e &#39;1,5d&#39; index.md
mv index.md ./docs
git add ./docs/*
git commit -am &#34;Updating all&#34;
git push
cd ..

for SITE in MikeLevin pythonically linuxpythonvimgit mikeateleven tardigradecircus removablefinger mike-levin lundervand pipulate whatsametafor guerillatech
do
    figlet $SITE -w 120
    cd $SITE
    git add _includes/*
    git add _posts/*
    git commit -am &#34;Updating all&#34;
    git push
    cd ..
done

figlet Done!
```

Okay, in my first testing of this capability, I&#39;m going to add some line-height
around my prev/next arrows by putting this:

    line-height: 3;

...into style.scss

Success! The URLs of my old MikeLev.in site didn&#39;t even break. Oh wow, this is
going to be nice.

Think through next steps. Every Little Project Gets Done!


</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-30-post-15.md">FILE: ../pythonically/_posts/2022-04-30-post-15.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-30-post-15.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Adding Style Sheets to Github Pages Jekyll Blog&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: adding-style-sheets-to-github-pages-jekyll-blog
permalink: /blog/adding-style-sheets-to-github-pages-jekyll-blog/
---

Okay, that was easy, adding the prev/next arrows to Jekyll blogs. But I&#39;m not
quite done. There&#39;s some CSS that completes the project.

It was a bit tricky to figure out. I don&#39;t normally do the sass css generators,
but it&#39;s built into Jekyll. The default css for Jekyll is the type of thing you
download and put in location locally just like a default.html or post.html. And
like them, there will be some transformations occurring, but instead of just
using a style.css you use a style.scss which does an import:

    ---
    ---

    @import &#39;jekyll-theme-hacker&#39;;

Using the CSS provided at the article I&#39;m working off of, I guessed that you
simply paste it underneath:

    ---
    ---

    @import &#39;jekyll-theme-hacker&#39;;

    .post-nav {
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
    }

    .post-nav p {
        flex: 1 1 0;
        width: 45%;
    }

    .post-nav p:first-child {
        padding-right: 0.5em;
    }

    .post-nav p:last-child {
        padding-left: 0.5em;
        text-align: right;
    }



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-30-post-14.md">FILE: ../pythonically/_posts/2022-04-30-post-14.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-30-post-14.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Adding Prev/Next Arrows to Github Pages Jekyll Blog Posts&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: adding-prev-next-arrows-to-github-pages-jekyll-blog-posts
permalink: /blog/adding-prev-next-arrows-to-github-pages-jekyll-blog-posts/
---

Hello, hello, hello! This is your Pythonic Ally again. The time has come the
walrus said to add previous/next links to the blog posts in the blog slice &amp;
dice system you just saw me create.

There are options for doing this (probably) in the Liquid template system that
Jekyll is built on. But since I&#39;m outputting these pages pythonically, I&#39;m
sitting on top of all the data I need right at the moment the files are
generated, so why not just put them directly in the markdown files? No need for
some templating system dependency!

Okay, good approach. Now think it through. This is a wonderful shining example
of why we keep our Python code both in a Jupyter Notebook and in a .py file. My
release system both creates and uses the .py file from the Notebook. I almost
never look at or think about the .py file that actually does the blog slicing
but it&#39;s always in sync with the Notebook version that I&#39;m always tweaking and
refining. Great workflow!

This is one such tweak.

It goes something like this:

Whenever we encounter the slicer-token (80 * &#34;-&#34;), we know to output the table
we must have just accumulated-up along with the date that we know to be in a
corresponding list of dates that we created from a prior spin-through. Actually
handling the dates was one of the more difficult parts of the blogslicer
project. The concept goes like this:

There is a slicer token above and below every blog post.

Therefore when spinning through a single-page-journal that&#39;s going to be sliced
&amp; diced into individual files, the first slicer-token encountered is a
throw-away one because it hasn&#39;t been &#34;accumulating up&#34; a blog post to that
point. However, on that first instance it is still important to grab the date
which it knows it&#39;s going to encounter on the next line. This slicer-token,
date-grab continues until the last slicer-token underneath of which there will
be no date. To make things easy, I just surround the attempts at date-grabs in
a try/except. That way the last slicer-token which has no date after it won&#39;t
generate an error.

Okay, so that&#39;s the system.

I had to do a loop ahead of time to know how many blog posts there are and so
the counter can count-down from the highest number down to 1. In this way, blog
posts will automatically always get the same title and URL if they have to be
auto-generated. So that first spin-through is necessary.

It&#39;s on the 2nd spin-through that title-logic is applied. Title logic can&#39;t be
moved to the 1st spin-through because that&#39;s what generates the requirements
for the 2nd spin-through. But without having the titles already on-hand, we
can&#39;t look-ahead to the next title, which is what would be necessary to create
the &#34;next&#34; arrow of a previous/next blog post navigator system.

It looks like we&#39;ll be doing a THIRD spin-through. This complexity may argue
for using what&#39;s built into Jekyll. Let me see if their blog posting system
accommodates for arrows. If not, I&#39;ll be doing a 3rd spin-through and appending
the arrows to the bottom of each blog-post file for sure. Not the biggest deal,
but investigate Jekyll post system first.

Here&#39;s a wonderful article that focuses on a CSS feature called flexbox:

[ByteDude&#39;s Jekyll blog post prev/next arrows](https://www.bytedude.com/jekyll-previous-and-next-posts/)

Me detects lots of rabbit-hole issues here. I haven&#39;t even thought about
formatting the prev/next arrows I was planning on &#34;manually&#34; inserting with
Python, and that&#39;s a point which the canned solutions cover well. So why not
just use the canned solution?

The only reason I can think why not is that I don&#39;t know how to override the
blog post template. But it couldn&#39;t be different than the normal page template,
right? I hope it won&#39;t make me have to add my Google Analytics code all over
again. Hopefully it&#39;s a nested or compositing or inheriting system... whatever
language you want to put on &#34;inner&#34; modifications not having to re-create all
the &#34;outer&#34; wrapper customizations. The outer-wrapper stuff of
\_layouts\default.html should still apply.

So I go to Github Hacker theme page [Github Pages Hacker Theme](https://github.com/pages-themes/hacker)

I grab the raw code at: [Raw Hacker Post Theme](https://raw.githubusercontent.com/pages-themes/hacker/master/_layouts/post.html)

I drop it into /github/pythonically/\_layouts and add it to the repo.

I edit out the code that adds tags, which I don&#39;t sue anyway. Commit and
push...

Okay, that worked. But I noticed another problem that the default title/url
that&#39;s created if there&#39;s no title explicitly set is causing a 404. I don&#39;t
know if it&#39;s a content issue or a blogslicer issue. Ugh! Nothing informative is
available anywhere to debug.

Oh, my bad! I just did a fast-track git commit/push without using my release
script which actually does all the blog slice &amp; dice work. Without using the
release script, links are bound to be broken. Remember that. Okay, the
\_layouts\post.html is doing its job exactly as hoped, meaning that the Google
Analytics tag manager code that I add with \_layouts/default.html are still
being applied. This is a compositing system. Excellent! Good work Jekyll on
that. So next step? Drop in the code from the article!

@g

...wait... Refresh... Yes! Success! Just that easy!

But I don&#39;t have the CSS yet. Hmmm. Well, I want to copy this file into
location for each of my sites.

Use my itersites.py file in /github/helpers/ to copy the post.html into
\_layouts, git add and git commit... okay, done.

Do a release and get at least some barebones (unformatted with CSS) prev/next
arrows propagated all over the place...



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-29-post-13.md">FILE: ../pythonically/_posts/2022-04-29-post-13.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-29-post-13.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Stop Using Stop-Words When They Reverse Meaning&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: stop-using-stop-words-when-they-reverse-meaning
permalink: /blog/stop-using-stop-words-when-they-reverse-meaning/
---

Ugh, after all that stopwords stuff from the earlier post, I&#39;m stripping it
out. The meaning can get totally mangled. For example, the title:

    Don’t Obfuscate A Perfectly Fine Pythonic FizzBuzz

...became the URL:

    https://pythonically.com/blog/obfuscate-perfectly-fine-pythonic-fizzbuzz/

Ugh! Unacceptable! Okay, so I stripped out all that stop_words stuff, and the
code is now:

```python
# export

import nltk
import argparse
from pathlib import Path
from dateutil import parser
from slugify import slugify


if hasattr(__builtins__, &#34;__IPYTHON__&#34;):
    from IPython.display import display, Markdown

    h1 = lambda text: display(Markdown(f&#34;# {text}&#34;))
    h2 = lambda text: display(Markdown(f&#34;## {text}&#34;))
    h3 = lambda text: display(Markdown(f&#34;### {text}&#34;))

    folder_name = &#34;../pythonically&#34;
    blog_title = &#34;Pythonic Ally Blog&#34;
    blog_slug = &#34;blog&#34;
else:
    h1 = lambda text: print(f&#34;# {text}&#34;)
    h2 = lambda text: print(f&#34;## {text}&#34;)
    h3 = lambda text: print(f&#34;## {text}&#34;)

    aparser = argparse.ArgumentParser()
    add_arg = aparser.add_argument
    add_arg(&#34;-p&#34;, &#34;--path&#34;, required=True)
    add_arg(&#34;-t&#34;, &#34;--title&#34;, required=True)
    add_arg(&#34;-s&#34;, &#34;--slug&#34;, required=True)
    args = aparser.parse_args()

    folder_name = args.path
    blog_title = args.title
    blog_slug = args.slug


index_front_matter = f&#34;&#34;&#34;---
layout: post
title: &#34;{blog_title}&#34;
slug: {blog_slug}
---

### [{blog_title} as One Page](/journal/)

&#34;&#34;&#34;

journal_path = f&#34;{folder_name}/journal.md&#34;
output_path = f&#34;{folder_name}/_posts/&#34;
slicer = &#34;-&#34; * 80

Path(output_path).mkdir(exist_ok=True)

dates = []
counter = -1
date_next = False
with open(journal_path, &#34;r&#34;) as fh:
    for line in fh:
        line = line.rstrip()
        if date_next:
            adate = line[3:]
            date_next = False
            adatetime = parser.parse(adate).date()
            dates.append(adatetime)
            date_next = False
        if line == slicer:
            date_next = True
            counter = counter + 1
dates.reverse()

table = []
at_top = True
index_list = []
with open(journal_path, &#34;r&#34;) as fh:
    for i, line in enumerate(fh):
        line = line.rstrip()
        if line == slicer:
            if at_top:
                at_top = False
                table = []
                continue
            adatetime = dates[counter - 1]
            filename = f&#34;{output_path}{adatetime}-post-{counter}.md&#34;
            h3(f&#34;FILE: {filename}&#34;)
            with open(filename, &#34;w&#34;) as fw:
                title = f&#34;Post {counter}&#34;
                slug = title
                if table[0] == slicer:
                    table = table[1:]
                maybe = table[1]
                has_title = False
                if table and maybe and maybe[0] == &#34;#&#34;:
                    title = maybe[maybe.find(&#34; &#34;) + 1 :]
                    has_title = True
                slug = slugify(title)
                top = []
                top.append(&#34;---\n&#34;)
                top.append(&#34;layout: post\n&#34;)
                top.append(f&#39;title: &#34;{title}&#34;\n&#39;)
                top.append(f&#34;categories: {blog_slug}\n&#34;)
                top.append(f&#34;slug: {slug}\n&#34;)
                link = f&#34;- [{title}](/{blog_slug}/{slug}/)&#34;
                index_list.append(link)
                top.append(&#34;---\n&#34;)
                top.append(&#34;\n&#34;)
                top_chop = 2
                if has_title:
                    top_chop = 3
                table = [f&#34;{x}\n&#34; for x in table[top_chop:]]
                table = top + table
                print(&#34;&#34;.join(table))
                fw.writelines(table)
            counter = counter - 1
            table = []
        table.append(line)

index_page = index_front_matter + &#34;\n\n&#34; + &#34;\n&#34;.join(index_list)

with open(f&#34;{folder_name}/blog.md&#34;, &#34;w&#34;) as fh:
    fh.writelines(index_page)
```



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-29-post-12.md">FILE: ../pythonically/_posts/2022-04-29-post-12.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-29-post-12.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Massaging 10 Sites Into Shape At Once&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: massaging-10-sites-into-shape-at-once
permalink: /blog/massaging-10-sites-into-shape-at-once/
---

Okay, I just removed stopwords from Jekyll blog post URLs. I did it quite
easily borrowing some code I recently did for [mlseo](https://pypi.org/project/mlseo/).
And next I think I want to roll the advances out across all my sites that could
benefit. Okay, so do it!

I just did whatsametafor.io. There were some interesting steps that I have to
remember:

- git mv index.md journal.md
- Put a new index.md in location
- Update the \_config.yml file

Do https://linuxpythonvimgit.com/ next and update that check-list. Also instead
of venturing into all these different Github.io templates (a mistake) focus on
one single template (hacker) so that you can move forward across all sites more
rapidly. Sure, they&#39;ll all look the same at first, but I can focus later on
divergence. It&#39;s convergence right now that accelerates the process.

Okay so let&#39;s do this thing.

- cd into ~/github/linuxpythonvimgit
- git mv index.md journal.md
- cp ../whatsametafor/index.md .
- Edits to index.md
- git add index.md
- mkdir \_posts

Ugh! Do this for every folder at once. Okay, so I put some &#34;source&#34; files into
my helper folder, such as a sample \_config.yml and index.md file. Then I
execute this script from Linux on Windows. Because of the use of git in the
commands, it is not an appropriate script to run from JuptyerLabs on Windows.

```python
from subprocess import run
from pathlib import Path


sites = &#34;&#34;&#34;guerillatech
linuxpythonvimgit
lundervand
mike-levin
mikeateleven
pipulate
pythonically
removablefinger
tardigradecircus
tictacufosightings
whatsametafor&#34;&#34;&#34;.split(&#39;\n&#39;)

ghp = &#34;/mnt/c/Users/mikle/github/&#34;

for site in sites:
    Path(f&#39;../{site}/_posts&#39;).mkdir(exist_ok=True)
    print(site)
    if not Path(f&#34;{ghp}{site}/index.md&#34;).is_file():
        run([&#34;cp&#34;, &#34;index.md&#34;, f&#34;{ghp}{site}/&#34;], cwd=f&#34;{ghp}helpers/&#34;)
    run([&#34;git&#34;, &#34;add&#34;, &#34;_posts&#34;], cwd=f&#34;{ghp}{site}/&#34;)
    run([&#34;git&#34;, &#34;add&#34;, &#34;blog.md&#34;], cwd=f&#34;{ghp}{site}/&#34;)
    run([&#34;git&#34;, &#34;add&#34;, &#34;index.md&#34;], cwd=f&#34;{ghp}{site}/&#34;)
    run([&#34;cp&#34;, &#34;_config.yml&#34;, f&#34;{ghp}{site}/&#34;], cwd=f&#34;{ghp}helpers/&#34;)
    run([&#34;git&#34;, &#34;add&#34;, &#34;_config.yml&#34;], cwd=f&#34;{ghp}{site}/&#34;)
    run([&#34;git&#34;, &#34;commit&#34;, &#34;-am&#34;, &#34;Added _posts&#34;], cwd=f&#34;{ghp}{site}/&#34;)
    print()
```


</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-29-post-11.md">FILE: ../pythonically/_posts/2022-04-29-post-11.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-29-post-11.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Removing Stopwords From Jekyll Blog URLs&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: removing-stopwords-from-jekyll-blog-urls
permalink: /blog/removing-stopwords-from-jekyll-blog-urls/
---

Yesterday I got the must-have features of my blogslicer program done. It can be
found in github as [blogslicer](https://github.com/miklevin/blogslicer/). This
is actually rather big in my life and one of the perfect &#34;because I&#39;m 50&#34;
projects. It&#39;s the first of my ELPGD (every little project gets done)
mentality. Honestly, I&#39;ve spent the last 15 years or so just re-educating
myself and getting tech-literate again.

- I once was tech-literate because of the Amiga computer. Then it went away.
- I again was tech-literate because of Microsoft Active Server Pages. Then it
  went away.
- I was fooled twice and refused to get fooled again.
  - So I passed over Ruby on Rails
  - So I passed over JavaScript on the server
- After long soul-searching, I settled on:
  - Linux
  - Python
  - vim
  - git

And I never looked back... oh, except when JavaScript took over the world as
&#34;the full webstack&#34;. Then I looked back, had buyer&#39;s remorse, looked more
closely at JavaScript and ECMA script, then was happy with my LPvg (Linux,
Python, vim &amp; git) decision. Ugh! I see the hamster wheel JavaScript folks are
on today and I see it as the institutionalization of the very tech-reset-button
I despise. Even if your core language stays the same, it&#39;s just as bad if the
core language is awful and all the frameworks based on it (out of necessity)
are both equally awful and constantly changing.

If I need a web-service (or web-anything, for that matter) there&#39;s Flask. There
always was Flask. There always will be Flask. And while there are many others
like FastAPI, pylons and the like, they&#39;re all optional higher-dependency
fad-driven edge cases that come and go. Flask always remains. It&#39;s too big to
fail and too widely deployed to not be upgraded. We see that in its embracing
of async/await... though the same can&#39;t be said of the ubiquitous Requests
package. But the point almost still stands because httpx came along as an
API-compatible version of Requests that does support async/await, so you don&#39;t
really have to relearn old stuff. You can just focus on the new. And when
Request finally does come around, chances are its implementation will be
similar enough to httpx that your career of computer literacy won&#39;t be nuked
the way it is in a move from React to Vue or from Vue to Svelte or whatnot.

Okay, all that&#39;s just sort of a deep-breath preamble to what I want to do next
on blogslicer. URLs are too long. I need to filter stop-words out of the URLs
when a custom URL is constructed from the title. This is instead of
implementing some arbitrary plug/slug replacement system. If you&#39;re basing URLs
on titles then you&#39;re basing URLs on titles. Most of the things you&#39;d want to
overwrite that for is editing out stopwords anyway. And so...

```python
import nltk
from nltk.corpus import stopwords

nltk.download(&#34;stopwords&#34;, quiet=True)
stops = stopwords.words(&#34;english&#34;)
...
slug = title.lower()
slug = &#34; &#34;.join([x for x in slug.split() if x not in stops])
```

Yup. And so now incorporate it into the code:

```python
# export

import nltk
import argparse
from dateutil import parser
from slugify import slugify
from nltk.corpus import stopwords

nltk.download(&#34;stopwords&#34;, quiet=True)
stops = stopwords.words(&#34;english&#34;)

if hasattr(__builtins__, &#34;__IPYTHON__&#34;):
    from IPython.display import display, Markdown

    h1 = lambda text: display(Markdown(f&#34;# {text}&#34;))
    h2 = lambda text: display(Markdown(f&#34;## {text}&#34;))
    h3 = lambda text: display(Markdown(f&#34;### {text}&#34;))

    folder_name = &#34;../pythonically&#34;
    blog_title = &#34;Pythonic Ally Blog Index&#34;
    blog_slug = &#34;blog&#34;
else:
    h1 = lambda text: print(f&#34;# {text}&#34;)
    h2 = lambda text: print(f&#34;## {text}&#34;)
    h3 = lambda text: print(f&#34;## {text}&#34;)

    aparser = argparse.ArgumentParser()
    add_arg = aparser.add_argument
    add_arg(&#34;-p&#34;, &#34;--path&#34;, required=True)
    add_arg(&#34;-t&#34;, &#34;--title&#34;, required=True)
    add_arg(&#34;-s&#34;, &#34;--slug&#34;, required=True)
    args = aparser.parse_args()

    folder_name = args.path
    blog_title = args.title
    blog_slug = args.slug


index_front_matter = f&#34;&#34;&#34;---
layout: post
title: &#34;{blog_title}&#34;
slug: {blog_slug}
---&#34;&#34;&#34;

journal_path = f&#34;{folder_name}/journal.md&#34;
output_path = f&#34;{folder_name}/_posts/&#34;
slicer = &#34;-&#34; * 80

dates = []
counter = -1
date_next = False
with open(journal_path, &#34;r&#34;) as fh:
    for line in fh:
        line = line.rstrip()
        if date_next:
            adate = line[3:]
            date_next = False
            adatetime = parser.parse(adate).date()
            dates.append(adatetime)
            date_next = False
        if line == slicer:
            date_next = True
            counter = counter + 1
dates.reverse()

h1(f&#34;There Are {counter} Posts:&#34;)

table = []
at_top = True
index_list = []
with open(journal_path, &#34;r&#34;) as fh:
    for i, line in enumerate(fh):
        line = line.rstrip()
        if line == slicer:
            if at_top:
                at_top = False
                table = []
                continue
            adatetime = dates[counter - 1]
            filename = f&#34;{output_path}{adatetime}-post-{counter}.md&#34;
            h3(f&#34;FILE: {filename}&#34;)
            with open(filename, &#34;w&#34;) as fw:
                title = f&#34;Post {counter}&#34;
                slug = title
                if table[0] == slicer:
                    table = table[1:]
                maybe = table[1]
                has_title = False
                if table and maybe and maybe[0] == &#34;#&#34;:
                    title = maybe[maybe.find(&#34; &#34;) + 1 :]
                    has_title = True
                slug = title.lower()
                slug = &#34; &#34;.join([x for x in slug.split() if x not in stops])
                slug = slugify(slug)
                top = []
                top.append(&#34;---\n&#34;)
                top.append(&#34;layout: post\n&#34;)
                top.append(f&#39;title: &#34;{title}&#34;\n&#39;)
                top.append(f&#34;categories: {blog_slug}\n&#34;)
                top.append(f&#34;slug: {slug}\n&#34;)
                link = f&#34;- [{title}](/{blog_slug}/{slug}/)&#34;
                index_list.append(link)
                top.append(&#34;---\n&#34;)
                top.append(&#34;\n&#34;)
                top_chop = 2
                if has_title:
                    top_chop = 3
                table = [f&#34;{x}\n&#34; for x in table[top_chop:]]
                table = top + table
                print(&#34;&#34;.join(table))
                fw.writelines(table)
            counter = counter - 1
            table = []
        table.append(line)

index_page = index_front_matter + &#34;\n\n&#34; + &#34;\n&#34;.join(index_list)

with open(f&#34;{folder_name}/blog.md&#34;, &#34;w&#34;) as fh:
    fh.writelines(index_page)
```

It&#39;s time to look into how to highlight specific lines of code in markdown
under Jekyll.



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-28-post-10.md">FILE: ../pythonically/_posts/2022-04-28-post-10.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-28-post-10.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Adding Command-Line Argument Support to Jupyter Notebook&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: adding-command-line-argument-support-to-jupyter-notebook
permalink: /blog/adding-command-line-argument-support-to-jupyter-notebook/
---

The time has come the walrus said to parameterize blogslicer. Running it in a
notebook is dandy, but incorporating it into my regular release process is
better. And my release process is a bash shell script.

Everyone should use bash shell scripts even if you&#39;re on Windows (as I am) or
Mac because it&#39;s one of those timeless skills that transcends all else in tech.

In case you didn&#39;t notice, tech is text and text is tricks. And so by the
transitive property of because-I-say-so, all tech is tricks. And by far one of
the greatest of all tricks is to take something you&#39;ve developed in a Jupyter
Notebook which could apply to a whole host of different situations and to turn
it into a parameterized package.

Huh? Yeah, that just means making the file.ipynb into a file.py and make sure
you can send it input-values on the command-line string. Sometimes these are
called parameters. And the parameters take arguments. Parameters have rules
like whether labeling the input with keywords is necessary or whether absolute
positions after the file.py have special meaning, such as:

```bash
blogslicer.py -foo bar
```

And so what we do is look at the Python standard library and find argparse. And
after years of shunning pip installs for something the standard library did
perfectly well, I&#39;m doing a complete 180. Most people will guide you towards
docopt (best package name ***ever***) or click. After a thorough cheerleading
session by Cecil Phillip on the [Talk Python to Me](https://talkpython.fm/episodes/show/363/python-for-.net-and-c-developers)
podcast, I&#39;m going to give Typer a try.

I&#39;m actually quite new to the Python mypy optional type annotation system which
typer seems to use, so this may be a new experience for me. I may have to add
type annotations to blogslicer, which will make this a doubly interesting
project. Okay, so 1, 2, 3... 1?

```python
pip install typer
```

The example at https://typer.tiangolo.com/ says... oh, boooo! This thing seems
to actually require the use of functions. Darn it! That&#39;s the thing about these
snooty right-way-to-do-things opinionated apps. Shoot, I was looking forward to
it too.

So do I change this journal entry? Nope! The process is as insightful as
anything else. So let me remind myself what it&#39;d look like with argparse.

```python
import argparse

parser = argparse.ArgumentParser()
add_arg = parser.add_argument
add_arg(&#34;-p&#34;, &#34;--path&#34;, required=True)
add_arg(&#34;-t&#34;, &#34;--title&#34;, required=True)
add_arg(&#34;-s&#34;, &#34;--slug&#34;, required=True)
args = parser.parse_args()
```

This is all well and good, but it won&#39;t run in a Jupyter Notebook. Okay, so I
need to create another Notebook as a test. I don&#39;t want to mix this in with the
good code yet. I&#39;m isolating a test:

```python
# export

if hasattr(__builtins__, &#34;__IPYTHON__&#34;):
    folder_name = &#34;../pythonically&#34;
    blog_title = &#34;Pythonic Ally Blog Index&#34;
    blog_slug = &#34;blog&#34;
else:
    import argparse

    parser = argparse.ArgumentParser()
    add_arg = parser.add_argument
    add_arg(&#34;-p&#34;, &#34;--path&#34;, required=True)
    add_arg(&#34;-t&#34;, &#34;--title&#34;, required=True)
    add_arg(&#34;-s&#34;, &#34;--slug&#34;, required=True)
    args = parser.parse_args()
    print(args)

    folder_name = args.path
    blog_title = args.title
    blog_slug = args.slug

print(folder_name, blog_title, blog_slug)
```

You will notice the export command at the top. That&#39;s for nbdev. There&#39;s also
another code-block in the notebook which sets the default file-name. The point
is here that I can use notebooks even to code up .py files that are not going
to run in the context of Jupyter. I use nbdev_build_lib which outputs the file.
And I test it like this:

```bash
python testargs.py -p &#34;./pythonically&#34; -t &#34;This is my title&#34; -s &#34;blog&#34;
./pythonically This is my title blog
```

And that is what we call a massive success! DocOpt? Click? Typer? Pishaw! Who
needs them. I&#39;ve reverted to my old belief that the good ol&#39; standard library
is arguably good enough for arguments.

And so now it&#39;s time to transplant my test code into blogslicer!

```python
# export

import dateutil
from slugify import slugify


try:
    from IPython.display import display, Markdown

    h1 = lambda text: display(Markdown(f&#34;# {text}&#34;))
    h2 = lambda text: display(Markdown(f&#34;## {text}&#34;))
    h3 = lambda text: display(Markdown(f&#34;### {text}&#34;))
    jn = True
except:
    h1 = lambda text: print(f&#34;# {text}&#34;)
    h2 = lambda text: print(f&#34;## {text}&#34;)
    h3 = lambda text: print(f&#34;## {text}&#34;)
    jn = False

if hasattr(__builtins__, &#34;__IPYTHON__&#34;):
    folder_name = &#34;../pythonically&#34;
    blog_title = &#34;Pythonic Ally Blog Index&#34;
    blog_slug = &#34;blog&#34;
else:
    import argparse

    parser = argparse.ArgumentParser()
    add_arg = parser.add_argument
    add_arg(&#34;-p&#34;, &#34;--path&#34;, required=True)
    add_arg(&#34;-t&#34;, &#34;--title&#34;, required=True)
    add_arg(&#34;-s&#34;, &#34;--slug&#34;, required=True)
    args = parser.parse_args()

    folder_name = args.path
    blog_title = args.title
    blog_slug = args.slug

index_front_matter = f&#34;&#34;&#34;---
layout: post
title: &#34;{blog_title}&#34;
slug: {blog_slug}
---&#34;&#34;&#34;

journal_path = f&#34;{folder_name}/journal.md&#34;
output_path = f&#34;{folder_name}/_posts/&#34;
slicer = &#34;-&#34; * 80

dates = []
counter = -1
date_next = False
with open(journal_path, &#34;r&#34;) as fh:
    for line in fh:
        line = line.rstrip()
        if date_next:
            adate = line[3:]
            date_next = False
            adatetime = dateutil.parser.parse(adate).date()
            dates.append(adatetime)
            date_next = False
        if line == slicer:
            date_next = True
            counter = counter + 1
dates.reverse()

h1(f&#34;There Are {counter} Posts:&#34;)

table = []
at_top = True
index_list = []
with open(journal_path, &#34;r&#34;) as fh:
    for i, line in enumerate(fh):
        line = line.rstrip()
        if line == slicer:
            if at_top:
                at_top = False
                table = []
                continue
            adatetime = dates[counter - 1]
            filename = f&#34;{output_path}{adatetime}-post-{counter}.md&#34;
            h3(f&#34;FILE: {filename}&#34;)
            with open(filename, &#34;w&#34;) as fw:
                title = f&#34;Post {counter}&#34;
                slug = title
                if table[0] == slicer:
                    table = table[1:]
                maybe = table[1]
                has_title = False
                if table and maybe and maybe[0] == &#34;#&#34;:
                    title = maybe[maybe.find(&#34; &#34;) + 1 :]
                    has_title = True
                slug = slugify(title)
                top = []
                top.append(&#34;---\n&#34;)
                top.append(&#34;layout: post\n&#34;)
                top.append(f&#39;title: &#34;{title}&#34;\n&#39;)
                top.append(f&#34;categories: {blog_slug}\n&#34;)
                top.append(f&#34;slug: {slug}\n&#34;)
                link = f&#34;- [{title}](/{blog_slug}/{slug}/)&#34;
                index_list.append(link)
                top.append(&#34;---\n&#34;)
                top.append(&#34;\n&#34;)
                top_chop = 2
                if has_title:
                    top_chop = 3
                table = [f&#34;{x}\n&#34; for x in table[top_chop:]]
                table = top + table
                print(&#34;&#34;.join(table))
                fw.writelines(table)
            counter = counter - 1
            table = []
        table.append(line)

index_page = index_front_matter + &#34;\n\n&#34; + &#34;\n&#34;.join(index_list)

with open(f&#34;{folder_name}/blog.md&#34;, &#34;w&#34;) as fh:
    fh.writelines(index_page)
```

Okay, but I see that I have 2 different places (and techniques) where I test
whether it&#39;s running in a Notebook or not. I should combine them as such:

```python
# export

import argparse
from dateutil import parser
from slugify import slugify


if hasattr(__builtins__, &#34;__IPYTHON__&#34;):
    from IPython.display import display, Markdown

    h1 = lambda text: display(Markdown(f&#34;# {text}&#34;))
    h2 = lambda text: display(Markdown(f&#34;## {text}&#34;))
    h3 = lambda text: display(Markdown(f&#34;### {text}&#34;))

    folder_name = &#34;../pythonically&#34;
    blog_title = &#34;Pythonic Ally Blog Index&#34;
    blog_slug = &#34;blog&#34;
else:
    h1 = lambda text: print(f&#34;# {text}&#34;)
    h2 = lambda text: print(f&#34;## {text}&#34;)
    h3 = lambda text: print(f&#34;## {text}&#34;)

    aparser = argparse.ArgumentParser()
    add_arg = aparser.add_argument
    add_arg(&#34;-p&#34;, &#34;--path&#34;, required=True)
    add_arg(&#34;-t&#34;, &#34;--title&#34;, required=True)
    add_arg(&#34;-s&#34;, &#34;--slug&#34;, required=True)
    args = aparser.parse_args()

    folder_name = args.path
    blog_title = args.title
    blog_slug = args.slug


index_front_matter = f&#34;&#34;&#34;---
layout: post
title: &#34;{blog_title}&#34;
slug: {blog_slug}
---&#34;&#34;&#34;

journal_path = f&#34;{folder_name}/journal.md&#34;
output_path = f&#34;{folder_name}/_posts/&#34;
slicer = &#34;-&#34; * 80

dates = []
counter = -1
date_next = False
with open(journal_path, &#34;r&#34;) as fh:
    for line in fh:
        line = line.rstrip()
        if date_next:
            adate = line[3:]
            date_next = False
            adatetime = parser.parse(adate).date()
            dates.append(adatetime)
            date_next = False
        if line == slicer:
            date_next = True
            counter = counter + 1
dates.reverse()

h1(f&#34;There Are {counter} Posts:&#34;)

table = []
at_top = True
index_list = []
with open(journal_path, &#34;r&#34;) as fh:
    for i, line in enumerate(fh):
        line = line.rstrip()
        if line == slicer:
            if at_top:
                at_top = False
                table = []
                continue
            adatetime = dates[counter - 1]
            filename = f&#34;{output_path}{adatetime}-post-{counter}.md&#34;
            h3(f&#34;FILE: {filename}&#34;)
            with open(filename, &#34;w&#34;) as fw:
                title = f&#34;Post {counter}&#34;
                slug = title
                if table[0] == slicer:
                    table = table[1:]
                maybe = table[1]
                has_title = False
                if table and maybe and maybe[0] == &#34;#&#34;:
                    title = maybe[maybe.find(&#34; &#34;) + 1 :]
                    has_title = True
                slug = slugify(title)
                top = []
                top.append(&#34;---\n&#34;)
                top.append(&#34;layout: post\n&#34;)
                top.append(f&#39;title: &#34;{title}&#34;\n&#39;)
                top.append(f&#34;categories: {blog_slug}\n&#34;)
                top.append(f&#34;slug: {slug}\n&#34;)
                link = f&#34;- [{title}](/{blog_slug}/{slug}/)&#34;
                index_list.append(link)
                top.append(&#34;---\n&#34;)
                top.append(&#34;\n&#34;)
                top_chop = 2
                if has_title:
                    top_chop = 3
                table = [f&#34;{x}\n&#34; for x in table[top_chop:]]
                table = top + table
                print(&#34;&#34;.join(table))
                fw.writelines(table)
            counter = counter - 1
            table = []
        table.append(line)

index_page = index_front_matter + &#34;\n\n&#34; + &#34;\n&#34;.join(index_list)

with open(f&#34;{folder_name}/blog.md&#34;, &#34;w&#34;) as fh:
    fh.writelines(index_page)
```

Pshwew! Okay, I think I&#39;ve got it. Now after I nbdev_build_lib, I can run this
on the command-line after cd&#39;ing into the blogslider/blogslicer subfolder that
nbdev creates.

```bash
python core.py -p &#34;../../pythonically&#34; -t &#34;Pythonic Ally Blog&#34; -s &#34;blog&#34;
```

And it worked! It output the sliced &amp; diced files into the correct Jekyll
\_posts folder, and so I am ready to incorporate this into my regular
publishing release script. I&#39;m tempted to put blogslicer into PyPi.org right
away, but there&#39;s no need so long as I can wrangle my paths correctly.

And it worked! I know because you&#39;re reading this as a result of me
incorporating the whole process into my regular release system.

What regular release system? Oh, the one that runs whenever I&#39;m blogging in vim
and press my @g macro... like I did just now. I won&#39;t overload this post with
my entire release script, but the part that publishes this site looks like
this:

```bash
figlet pythonically -w 120
python ./blogslicer/blogslicer/core.py -p &#34;./pythonically&#34; -t &#34;Pythonic Ally Blog&#34; -s &#34;blog&#34;
cd pythonically
# git pull
git add _includes/*
git add _posts/*
git commit -am &#34;Updating all&#34;
git push
cd ..
```

And so the world has changed forever for me with one little incremental step
forward.


</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-28-post-9.md">FILE: ../pythonically/_posts/2022-04-28-post-9.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-28-post-9.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Don&#39;t Obfuscate A Perfectly Fine Pythonic FizzBuzz&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: don-t-obfuscate-a-perfectly-fine-pythonic-fizzbuzz
permalink: /blog/don-t-obfuscate-a-perfectly-fine-pythonic-fizzbuzz/
---

Do you know FizzBuzz? If you&#39;re here, you probably do. But did you know that
you don&#39;t have to check whether the result of the modulo operator in Python
equals zero? In Python 0 evaluates false. Someone&#39;s gotta read The Hitchhiker&#39;s
Guide to Python.

So here&#39;s the FizzBuzz that you should know and love. Yes, there are other
ways. But what are you doing, entering a PERL obfuscation contest? Readability
counts! So impress your interviewer by knowing that this:

```python
for i in range(1, 101):
    if i % 3 == 0 and i % 5 == 0:
        print(&#34;FizzBuzz&#34;)
    elif i % 3 == 0:
        print(&#34;Fizz&#34;)
    elif i % 5 == 0:
        print(&#34;Buzz&#34;)
    else:
        print(i)
```

...is the same as this:

```python
for i in range(1, 101):
    if not i % 3 and not i % 5:
        print(&#34;FizzBuzz&#34;)
    elif not i % 3:
        print(&#34;Fizz&#34;)
    elif not i % 5:
        print(&#34;Buzz&#34;)
    else:
        print(i)
```

You might not think so, but this is of endless use in any situation where you
have to do something on the first iteration of a loop but not the subsequent
iterations. Sure you can check if i == 0 but isn&#39;t this cleaner?

```python
for i in range(10):
    if not i:
        print(f&#39;{i} is first&#39;)
```

And if you really must obfuscate it, at least do it in a Pythonic and
memory-efficient way:

```python
for i in range(1, 101):
    if not all((i % x for x in (3, 5))):
        print(&#34;FizzBuzz&#34;)
    elif not i % 3:
        print(&#34;Fizz&#34;)
    elif not i % 5:
        print(&#34;Buzz&#34;)
    else:
        print(i)
```

Readability counts! If some snotty Reddit HackerNews StackOverflow snot trys to
show you something involving importing packages or lambda commands, tell them
to:

```python
import this
```



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-27-post-8.md">FILE: ../pythonically/_posts/2022-04-27-post-8.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-27-post-8.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Creating Blog Index Page for Jekyll&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: creating-blog-index-page-for-jekyll
permalink: /blog/creating-blog-index-page-for-jekyll/
---

Jekyll has a way of creating index pages to expose links to the blog posts.


```python
import dateutil
from slugify import slugify


try:
    from IPython.display import display, Markdown

    h1 = lambda text: display(Markdown(f&#34;# {text}&#34;))
    h2 = lambda text: display(Markdown(f&#34;## {text}&#34;))
    h3 = lambda text: display(Markdown(f&#34;### {text}&#34;))
    jn = True
except:
    h1 = lambda text: print(f&#34;# {text}&#34;)
    h2 = lambda text: print(f&#34;## {text}&#34;)
    h3 = lambda text: print(f&#34;## {text}&#34;)
    jn = False

folder_name = &#34;../pythonically&#34;
blog = &#34;blog&#34;

index_front_matter = f&#34;&#34;&#34;---
layout: post
title: &#34;Pythonic Ally Blog Index&#34;
slug: {blog}
---&#34;&#34;&#34;

journal_path = f&#34;{folder_name}/journal.md&#34;
output_path = f&#34;{folder_name}/_posts/&#34;
slicer = &#34;-&#34; * 80

dates = []
counter = -1
date_next = False
with open(journal_path, &#34;r&#34;) as fh:
    for line in fh:
        line = line.rstrip()
        if date_next:
            adate = line[3:]
            date_next = False
            adatetime = dateutil.parser.parse(adate).date()
            dates.append(adatetime)
            date_next = False
        if line == slicer:
            date_next = True
            counter = counter + 1
dates.reverse()

h1(f&#34;There Are {counter} Posts:&#34;)

table = []
at_top = True
index_list = []
with open(journal_path, &#34;r&#34;) as fh:
    for i, line in enumerate(fh):
        line = line.rstrip()
        if line == slicer:
            if at_top:
                at_top = False
                table = []
                continue
            adatetime = dates[counter - 1]
            filename = f&#34;{output_path}{adatetime}-post-{counter}.md&#34;
            h3(f&#34;FILE: {filename}&#34;)
            with open(filename, &#34;w&#34;) as fw:
                title = f&#34;Post {counter}&#34;
                slug = title
                if table[0] == slicer:
                    table = table[1:]
                maybe = table[1]
                has_title = False
                if table and maybe and maybe[0] == &#34;#&#34;:
                    title = maybe[maybe.find(&#34; &#34;) + 1 :]
                    has_title = True
                slug = slugify(title)
                top = []
                top.append(&#34;---\n&#34;)
                top.append(&#34;layout: post\n&#34;)
                top.append(f&#39;title: &#34;{title}&#34;\n&#39;)
                top.append(f&#34;categories: {blog}\n&#34;)
                top.append(f&#34;slug: {slug}\n&#34;)
                link = f&#34;- [{title}](/{blog}/{slug}/)&#34;
                index_list.append(link)
                top.append(&#34;---\n&#34;)
                top.append(&#34;\n&#34;)
                top_chop = 2
                if has_title:
                    top_chop = 3
                table = [f&#34;{x}\n&#34; for x in table[top_chop:]]
                table = top + table
                print(&#34;&#34;.join(table))
                fw.writelines(table)
            counter = counter - 1
            table = []
        table.append(line)

index_page = index_front_matter + &#34;\n\n&#34; + &#34;\n&#34;.join(index_list)

with open(f&#34;{folder_name}/blog.md&#34;, &#34;w&#34;) as fh:
    fh.writelines(index_page)
```



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-27-post-7.md">FILE: ../pythonically/_posts/2022-04-27-post-7.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-27-post-7.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Every Little Project Gets Done (ELPGD)&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: every-little-project-gets-done-elpgd
permalink: /blog/every-little-project-gets-done-elpgd/
---

Okay, I did such good work on this blogslicer app. It&#39;s working in a repo
folder side-by-side with other repo folders, which is very important. It&#39;s easy
to get stuff to work relative to files within the same folder. But to get
something to step up **out** of its own folder, **over** and into another
folder and to work there doesn&#39;t always go as smoothly.

This is an important project for me because it opens the doors to the next and
the next project. It&#39;s an example of ELPID (every little project is doable). If
you can imagine it, it can get done... of course within a certain reason. You
can&#39;t raise a city into the clouds, but you can create a blog slice &amp; dice
system in a few days that will change your life forever. It&#39;s a perfect case of
the releasing built-up potential that I&#39;m always talking about.

I put a link to the one long journal file on this site&#39;s homepage. But now I
need links to the sliced &amp; diced version. I need to create a blog index page...

Alright! A big breakthrough. You can&#39;t put stuff without the date file naming
convention into \_posts. Instead, you put it in the repo root, but with
something like this:

```markdown
---
layout: post
title: &#34;Blog Index&#34;
slug: blog
---

This is a test.
```



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-26-post-6.md">FILE: ../pythonically/_posts/2022-04-26-post-6.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-26-post-6.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Turning Repo into nbdev Project&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: turning-repo-into-nbdev-project
permalink: /blog/turning-repo-into-nbdev-project/
---

Let&#39;s see how quickly you can get blogslicer in PyPi.org as an nbdev project.

Okay, I just:

- Created ~/github/blogslicer
- Created github repo
- Tied the 2 together and pushed
- Did nbdev_new
- Edited settings.ini
- Moved and renamed the notebook into repo
- Attempted nbdev_clean_nbs (didn&#39;t appear to work)
- Added notebook to repo and pushed

Okay, what next? Make the new one which is now named 00_core.py work on files
that are not in its own directory.

I added the various cells and comments that nbdev needs. nbdev_clean_nbs is now
doing its thing. This stuff is only now going to be published as a result of
this process working.

I should alter pythonically.com to not use index.md as the journal or the
homepage. Instead, it will be journal.md and I will put another index.md in
location. I will have to quit out of vim where I have all my site journals
loaded and edit the all.sh file with the new filename. Don&#39;t do this with ALL
your sites yet. Just start with pythonically.com and see how it goes.



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-26-post-5.md">FILE: ../pythonically/_posts/2022-04-26-post-5.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-26-post-5.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Using Blog Titles for Filenames&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: using-blog-titles-for-filenames
permalink: /blog/using-blog-titles-for-filenames/
---

Made a lot of good progress yesterday on the blog slice &amp; dice system. Just
have to get that title stuff down. Okay, got it done. There are little
concessions here and there because I&#39;m keeping my blogging format mostly
intact.

```python
import dateutil
from slugify import slugify
from IPython.display import display, Markdown


h1 = lambda text: display(Markdown(f&#34;# {text}&#34;))
h2 = lambda text: display(Markdown(f&#34;## {text}&#34;))
h3 = lambda text: display(Markdown(f&#34;### {text}&#34;))

site_base = &#34;https://pythonically.com&#34;
slicer = &#34;-&#34; * 80

dates = []
counter = -1
date_next = False
with open(&#34;./index.md&#34;, &#34;r&#34;) as fh:
    for line in fh:
        line = line.rstrip()
        if date_next:
            adate = line[3:]
            date_next = False
            adatetime = dateutil.parser.parse(adate).date()
            dates.append(adatetime)
            date_next = False
        if line == slicer:
            date_next = True
            counter = counter + 1
dates.reverse()

h1(f&#34;There Are {counter} Posts:&#34;)

table = []
at_top = True
with open(&#34;./index.md&#34;, &#34;r&#34;) as fh:
    for i, line in enumerate(fh):
        line = line.rstrip()
        if line == slicer:
            if at_top:
                at_top = False
                table = []
                continue
            adatetime = dates[counter - 1]
            filename = f&#34;./_posts/{adatetime}-post-{counter}.md&#34;
            h3(f&#34;FILE: {filename}&#34;)
            with open(filename, &#34;w&#34;) as fw:
                title = f&#34;Post {counter}&#34;
                if table[0] == slicer:
                    table = table[1:]
                maybe = table[1]
                has_title = False
                if table and maybe and maybe[0] == &#34;#&#34;:
                    title = maybe[maybe.find(&#34; &#34;) + 1 :]
                    title = slugify(title)
                    has_title = True
                top = []
                top.append(&#34;---\n&#34;)
                top.append(&#34;layout: post\n&#34;)
                top.append(f&#39;title: &#34;{title}&#34;\n&#39;)
                top.append(&#34;categories: blog\n&#34;)
                slug = title.lower().replace(&#34; &#34;, &#34;-&#34;)
                top.append(f&#34;slug: {slug}\n&#34;)
                top.append(&#34;---\n&#34;)
                top.append(&#34;\n&#34;)
                top_chop = 2
                if has_title:
                    top_chop = 3
                table = [f&#34;{x}\n&#34; for x in table[top_chop:]]
                table = top + table
                # display(Markdown(&#39;&#39;.join(table)))
                print(&#34;&#34;.join(table))
                fw.writelines(table)
            counter = counter - 1
            table = []
        table.append(line)
```



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-25-post-4.md">FILE: ../pythonically/_posts/2022-04-25-post-4.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-25-post-4.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Slicing &amp; Dicing Single File to Jekyll Blog Posts&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: slicing-dicing-single-file-to-jekyll-blog-posts
permalink: /blog/slicing-dicing-single-file-to-jekyll-blog-posts/
---

I pushed out a few livestreams yesterday slice and dicing these single long
journal files into smaller separate files. I did it under the pressure of
livestreaming and didn&#39;t quite bring it to completion. I need to do a wee bit
more exercise in clear thinking. I did a pretty good job of a rough first pass,
but that&#39;s how bugs get in. Rough first pass needs a sort of clarity
superimposed on it afterwards. You can&#39;t ***always*** work like Roomba, just
backing up, turning a little and retrying. Sometimes you need to look at the
entire situation and make higher-order determinations.

One of the ways to do this is to be very precise about the debugging messages
that you output while the script runs. This output is side-effects of the
script. The functional result of running the script is the same whether the
print statement output is shown or not, so the print statement is purely for me
during the running of the script. Make it work for me better.

Get your in-Notebook headlines!

Okay, headlines are in. Putting in headlines makes everything start to fall in
place. The hierarchy implied by headlines, especially h1, h2 &amp; h3 are highly
clarifying.

Pshwew! That took some wrangling. It turned out that there&#39;s some sort of
nuances keeping the Title from working as URLs, or at least easily. I
pre-process the titles into slugs and use the slugs in the frontmatter and
\_config.yml file.

I&#39;ll have to maybe do another video or publish the code or something. Suffice
to say I have the &#34;success assured&#34; moment now under my belt. I have just a bit
more pushing to do to hit this project home.

I need to have a more sensible default filename. Right now the URLs would
change every time I sliced &amp; diced the journal because the counter goes UP as
it goes through the file, but the fine is in reverse chronological notation.

What are my blogging conventions?

The page slicer token is always 80 hyphens. That&#39;s such a clean &#34;cut&#34;.

There needs to be a slicer token at the bottom of the document indicating the
&#34;last&#34; or perhaps the &#34;first&#34; post, depending on how you think about it.

Okay, done. I had to start the counter from -1 to get it right. It counts-up
and then counts-down. The URLs will never change so long as the headline never
changes. But these things have no headlines. Fix that, but make them optional.
You have a system now that creates a very nice default URL /blog/post-n/



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-24-post-3.md">FILE: ../pythonically/_posts/2022-04-24-post-3.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-24-post-3.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Hello World&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: hello-world
permalink: /blog/hello-world/
---

Hello World! Practicing Jekyll blogging.



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-23-post-2.md">FILE: ../pythonically/_posts/2022-04-23-post-2.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-23-post-2.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;How To Control URLs and Links in Jekyll&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: how-to-control-urls-and-links-in-jekyll
permalink: /blog/how-to-control-urls-and-links-in-jekyll/
---

We are blogging using just a plain old text-file which currently becomes one
long file on pythonically.com. On my last video I got Jekyll&#39;s default blog
post system working. Jekyll is a static site publishing system built into
Github. The feature is called Github pages.

We changed our theme of Github Pages (through Github.com / Settings / Pages)

We did a git pull.

That got us our \_config.yml file.

I&#39;m following the instructions on this fine article:
https://www.digitalocean.com/community/tutorials/how-to-control-urls-and-links-in-jekyll

I&#39;m waiting for the Jekyll changes to propagate.

Success!



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-23-post-1.md">FILE: ../pythonically/_posts/2022-04-23-post-1.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-23-post-1.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;My First Jekyll Blog Post&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: my-first-jekyll-blog-post
permalink: /blog/my-first-jekyll-blog-post/
---

Hello World! Each of these Github Pages sites starts out as a journal like
this.

### APIs in Math vs. APIs in Python

I think out loud regarding why I&#39;m not a &#34;math person&#34; even though by all
rights I should be. I realize I&#39;m hyper-literal in my internalization and
application of &#34;da rulez&#34;. High school algebra in particular limits my
capability for the sort of abstract thought required for higher mathematics.

{% include youtubePlayer.html id=&#34;TCNpKUj53fo&#34; %}

I hit the point home with this video where I show a division operator in Python
(/) being overwritten by pathlib and the default Python slice API being
overwritten by Pandas.

{% include youtubePlayer.html id=&#34;FDYRQbw6X4M&#34; %}

If I&#39;m going to do better practicing what I preach, I can&#39;t have these long
journal pages as my main homepages of these various sites. So, I need to think
about slice &amp; dicing the sites... and releasing the potential of the tools I&#39;m
using, doing as little re-invention as possible UNLESS it&#39;s absolutely called
for... in which case it wouldn&#39;t really be re-invention.

I have done a WordPress to Jekyll import (MikeLev.in) and I can look at it as
an example... but why? Go for the ideal if it exists. See how Jekyll WANTS you
to blog. Lean into the strengths of the tool.

- Keep your original data in whatever format works best for you.
  - For me, that&#39;s one long journal-like text-file (for life)
- Focus on the &#34;transforms&#34;
  - You can always adjust your transforms
  - You don&#39;t really even rely on Jekyll
  - Keep yourself platform-independent
- The platforms you&#39;re not independent of &#34;always&#34; include:
  - Linux
  - Python
  - vim
  - git

We are NOT migrating a blog. We&#39;re starting from scratch, so this page:
https://jekyllrb.com/docs/posts/

I put a file in location to test the system.

https://pythonically.com/2022/04/23/My-First-Jekyll-Blog-Post.html

Great success.

There&#39;s much still to learn, especially about controlling that URL (categories
&amp; tags)... but this is a &#34;success assured&#34; moment. All I need to do is add a
slice &amp; dice process to my master publishing script.

Okay, wow, so I got the title logic in. Now slap some headlines on these blog
posts. A few with, a few without.


</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">load_ext</span> lab_black
<span class="o">%</span><span class="k">reload_ext</span> lab_black
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-05-01-post-20.md">FILE: ../pythonically/_posts/2022-05-01-post-20.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-05-01-post-20.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Pushing Blogslicer to PyPI (From Jupyter Notebook)&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: pushing-blogslicer-to-pypi-from-jupyter-notebook
permalink: /blog/pushing-blogslicer-to-pypi-from-jupyter-notebook/
---

I hate smart quotes. I don&#39;t think they&#39;re good for SEO (search engine
optimization). I adhere to a principle called &#34;The Weakest Link In The Chain&#34;.
Unfortunately such a good metaphor has been tarnished by that awful game show
of the same name years back, but the concept will last longer than memories of
that atrocity, so I will keep using it.

Every Little Thing gets done, or ELTgd, as I&#39;m currently acronym&#39;ing it. I get
smart quotes when I copy/paste out of other more word-processing oriented
software into vim where I blog. There&#39;s many ways I could address fixing this,
but I have a release script that slices &amp; dices my single-long-page text files
that I blog in (one journal for life, one journal per website) into separate,
individually optimized pages.

I actually don&#39;t sweat the optimization too much. I let my confidence that I
will gradually massage and organize sites over time allow me to write at
full-speed. And I do write fast. My typing speed isn&#39;t really that fast.
Neither is my thinking speed. It&#39;s just that both are decent speed and in sync
with each other, so I write just a bit slower than I can talk, and that means I
can publish a lot... a whole lot, and so I do... now... as a result of
operation ELTgd.

This particular blog post on Pythonic Ally is to see how quickly I can get a
package called &#34;dumbquotes&#34; into PyPi. For you see, the next step in my
blogslicer (also soon to be in PyPI) is to strip out smart quotes, and I don&#39;t
see why that can&#39;t and shouldn&#39;t be a separate package of potentially broader
use than blogslicer if made separate.

Okay, so before I do dumbquotes, I want to get blogslicer into PyPi.org. I use
a developer tool called nbdev from the illustrious Australian and all around
cool guy, Jeremy Howard of Fast.ai. If you&#39;re into Machine Learning, I suggest
all his stuff over the competing Google TensorFlow because with TensorFlow, all
things lead to the vendor-trap. But with fast.ai, all roads lead to generic
GPU-based less vendor dependt goodness.

But I digress. I&#39;ve already refined blogslicer a bit in Github. Making it pip
installable should be a breeze. 1, 2, 3... 1?

Quickly edit the index.ipynb which gets turned into the README.md which becomes
the Github repo homepage documentation. Important! Okay, done but my trick for
switching between Notebook mode and command-line mode arguments is causing an
error on:

```python
#hide
from blogslicer.core import *
```

So I&#39;m just commenting out that import and tabling the issue for now. Next?
Look at my release system. Even though I don&#39;t NEED to bump the version, that
is usually my next step. And I&#39;m doing everything manually first. Then I&#39;ll put
it into my release script.

```bash
$ nbdev_bump_version
Old version: 0.0.1
New version: 0.0.2
```

Okay, that went off without a hitch. Next!

```bash
$ nbdev_build_docs
```

...oops! A glorious error, probably related to the above problem importing
blogslicer.core into the index.ipynb. nbdev has its weirdness. It&#39;ll just be a
matter of practice, but I&#39;ll skip it for now. Next!

```bash
$ nbdev_build_lib
Converted 00_core.ipynb.
Converted index.ipynb.
```

Okay, that ran without a hitch and that&#39;s the important one. Next!

```bash
nbdev_clean_nbs
```

No output, but that means it ran well. Always a good idea before:

```bash
git commit -am &#34;Preparing for first PyPI release&#34;
(output removed)
(py310) ubuntu@LunderVand:/mnt/c/Users/mikle/github/blogslicer$ git push
(output removed)
```

Next!

```bash
$ mkdir dist
$ python3 -m build
(lots of output removed)
Successfully built blogslicer-0.0.2.tar.gz and blogslicer-0.0.2-py3-none-any.whl
```

And finally...

```bash
$ twine upload dist/*
Uploading distributions to https://upload.pypi.org/legacy/
Uploading blogslicer-0.0.2-py3-none-any.whl
100% ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 12.6/12.6 kB • 00:00 • 461.3 kB/s
Uploading blogslicer-0.0.2.tar.gz
100% ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 13.7/13.7 kB • 00:00 • 718.8 kB/s

View at:
https://pypi.org/project/blogslicer/0.0.2/
```

Success! But without the documentation successfully built, both the Github repo
page and PyPi package page contain a generic nbdev template. Ugh! That can&#39;t
stand. Okay, diagnose that quickly. No rabbit holes!

Okay, I was able to uncomment the index.ipynb package import by changing the
Jupyter environment check to control where the arguments come from like so:

```python
if hasattr(__builtins__, &#34;__IPYTHON__&#34;) or __name__ != &#39;__main__&#39;:
    from IPython.display import display, Markdown

    h1 = lambda text: display(Markdown(f&#34;# {text}&#34;))
    h2 = lambda text: display(Markdown(f&#34;## {text}&#34;))
    h3 = lambda text: display(Markdown(f&#34;### {text}&#34;))

    folder_name = &#34;../pythonically&#34;
    blog_title = &#34;Pythonic Ally Blog&#34;
    blog_slug = &#34;blog&#34;
    author = &#34;Mike Levin&#34;
else:
    h1 = lambda text: print(f&#34;# {text}&#34;)
    h2 = lambda text: print(f&#34;## {text}&#34;)
    h3 = lambda text: print(f&#34;## {text}&#34;)

    aparser = argparse.ArgumentParser()
    add_arg = aparser.add_argument
    add_arg(&#34;-p&#34;, &#34;--path&#34;, required=True)
    add_arg(&#34;-t&#34;, &#34;--title&#34;, required=True)
    add_arg(&#34;-s&#34;, &#34;--slug&#34;, required=True)
    add_arg(&#34;-a&#34;, &#34;--author&#34;, required=True)
    args = aparser.parse_args()

    folder_name = args.path
    blog_title = args.title
    blog_slug = args.slug
    author = args.author
```

I know it worked without breaking the command-line (using &#34;python&#34; in the
command) input because you&#39;re reading this. And so I&#39;ve finally completed my
pattern for creating packages in Jupyter Notebooks (really, JupyterLab) and
having them also work as parameterized command-line tools releasable into PyPI.
I still have a little work to go to make it work without the python interpreter
prefix. I&#39;ve got some research to do on how pip installing results in
CLI-runnable commands.

So now onto dumb-quotes. I&#39;m going to hold off on putting the actual PyPI
release into my everyday frequently used blog release script. I thing that may
cause more harm than good. But definitely a topic for later is bringing the
PyPI package up-to-date with my fast-and-furious daily code tweaking.

Okay, so one more time, but from scratch (blogslicer was already well
underway).









</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-05-01-post-19.md">FILE: ../pythonically/_posts/2022-05-01-post-19.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-05-01-post-19.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Sharpening My Prev/Next Arrows&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: sharpening-my-prev-next-arrows
permalink: /blog/sharpening-my-prev-next-arrows/
---

It turned out that what was &#34;most broken&#34; in my opinion was the formatting of
the previous/next arrows. I put so much effort into just having them at all
over the past day that it&#39;d be silly to stop before I tweaked them to an
acceptable point. You&#39;re probably looking at them now. Makes you want to click
them, doesn&#39;t it? Well, here&#39;s the secret sauce.

Here&#39;s the style.scss

    ---
    ---

    @import &#39;jekyll-theme-hacker&#39;;

    .spacer {
        padding-top: 1.5em;
        padding-bottom: 1.5em;
    }

    .post-nav {
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
    }

    .post-nav-prev {
        text-align: left;
    }

    .post-nav-next {
        text-align: right;
    }

And here&#39;s the post.html. I use a very old-school non-breaking-space trick
here, but it works super-well. There&#39;s some flexbox wrangling here and its
flex sub-command I&#39;m still getting a handle on. I may make it more elegant in
the future, but the way it displays certainly looks elegant.

And of course the other tired old trick of yet-another-div because padding or
whatever doesn&#39;t work correctly on the inner one.

...opps, apparently I can&#39;t show you that until I learn about neutralizing and
escaping Jekyll blog post Liquid directives better.

Oh, and the reason vim is better than emacs is because



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-05-01-post-18.md">FILE: ../pythonically/_posts/2022-05-01-post-18.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-05-01-post-18.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Making YouTube Embeds 100% Width But Fixed Aspect Ratio Height&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: making-youtube-embeds-100-width-but-fixed-aspect-ratio-height
permalink: /blog/making-youtube-embeds-100-width-but-fixed-aspect-ratio-height/
---

There&#39;s a number of potential directions to go now. The temptation is to start
doing stupid SEO-tricks at the Pipulate.com site. Specifically, it&#39;s time to
spin through my &gt;1000 YouTube videos from over the years and spit out static
wrapper-pages for them. Or more specifiably, spit out a single journal-format
page that has the slicer-token, date, video title as page title and video
description as page content, and of course the YouTube embed code. So then I
will have a series of pages that you could next, next, next through using the
prev/next arrows. And I sort and categorize the videos to make topical
groupings somehow. I may bring back the Jekyll blog post tags which I edited
out of posts.html.

That&#39;s the temptation, anyhow. But the reality is that before I do such an
indulgent project, I should really finish the last few bits of obvious Jekyll
housekeeping that call out to me. I want to externalize the Google Analytics
code so that the default.html is smaller. There&#39;s no reason to have the
specific GA implementation hardwired into default.html. Okay, so it&#39;s education
time. I really ought to install Jekyll locally at some point to have even more
hands-on, but that&#39;s the messy tech liability stuff I&#39;m trying to avoid. If
you&#39;re going to enjoy the magic of hand-waving, Github Pages is exactly where
to do it. So keep my life simple and just find the magic gestures.

There&#39;s this [tutorial page on what Jekyll layouts are](https://jekyllrb.com/docs/step-by-step/04-layouts/)
that shows even default.html can have those Liquid curly braces in them. I&#39;m
using something like that for the youtubePlayer.html include. So right off, I&#39;m
going to change the size of that thing to be 100% width. Seeing YouTube embeds
create a horizontal scroll in mobile has been bugging me. So start with that
and make a tiny assertion of control...

Before

```html
&lt;iframe src=&#34;https://www.youtube.com/embed/{{ include.id }}&#34;
    width=&#34;560&#34;
    height=&#34;315&#34;
    frameborder=&#34;0&#34;
    allowfullscreen&gt;
&lt;/iframe&gt;
```

After

```html
&lt;iframe src=&#34;https://www.youtube.com/embed/{{ include.id }}&#34;
    style=&#34;width: 100%;&#34;
    frameborder=&#34;0&#34;
    allowfullscreen&gt;
&lt;/iframe&gt;
```

@g

...yep, success! YouTube videos are now attractively screen-width, even if that
screen is a tiny mobile phone. Oops, but it&#39;s height is squashed. Research
that...

Top-10 answers on the board... survey says!
[Jim Fisher has the answer](https://jameshfisher.com/2017/08/30/how-do-i-make-a-full-width-iframe/)
the answer being use a container div with relative positioning and a 56.25% for
padding top. Go figure! Here&#39;s the code for \_layouts/youtubePlayer.html that
works for me in Edge mobile and Chrome desktop (and probably everywhere else
even semi-modern):

```html
&lt;div&gt;
  &lt;div style=&#34;position:relative;padding-top:56.25%;&#34;&gt;
    &lt;iframe src=&#34;https://www.youtube.com/embed/{{ include.id }}&#34; frameborder=&#34;0&#34; allowfullscreen
      style=&#34;position:absolute;top:0;left:0;width:100%;height:100%;&#34;&gt;&lt;/iframe&gt;
  &lt;/div&gt;
&lt;/div&gt;
```

BAM!


</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-05-01-post-17.md">FILE: ../pythonically/_posts/2022-05-01-post-17.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-05-01-post-17.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Disabling Github CI nbdev_install_git_hooks&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: disabling-github-ci-nbdev-install-git-hooks
permalink: /blog/disabling-github-ci-nbdev-install-git-hooks/
---

I just updated my release script using a bash loop. That was very satisfying. I
guess I question now how much these next steps on the blogslicer project belong
here on Pythonic Ally. All this Github Pages Jekyll stuff... not really even
sure where it belongs. Maybe SEO? I&#39;m using MikeLevinSEO.com for the mlseo repo
page. Maybe Mike-Levin.com? Or just on plain MikeLev.in. Anyway, I can sort
that out as I go. Don&#39;t lose momentum is the important thing.  And on the front
of not losing momentum, it&#39;s time to ask my standard questions:

1. What&#39;s most broken?
2. Where do I get the biggest bang for the buck?
3. What plates need to be spun?

Oh! USING mlseo is the process of Pipulating. And so it&#39;s just about time to
bring pipulate.com back to life applying everything form mlseo and creating
that righteous feedback loop to push forward the usefulness of mlseo.

Okay, so every time I push to pipulate or blogslicer, I get a Github CI Run
failed email. nbdev enables Github continuous integration (CI) with a
easy-to-run script after you nbdev_new so long as your repo is public. It&#39;s
tempting to do, but whatever it does causes errors on every push, so I found
this page to [disable Github CI](https://docs.github.com/en/actions/managing-workflow-runs/disabling-and-enabling-a-workflow)
I followed the instructions and just deleted all my &#34;Run Failed&#34; CI emails. Now
I&#39;m running my release script again...

And it worked! Wow, yeah, this is not Pythonic Ally at all anymore. Neither is
it the type of thing I really want to put on the Linux, Python, vim &amp; git site.
No, this is feeling a lot like what SHOULD be on mikelevinseo.com BEFORE I
turned it into the repo page for mlseo. I may have to rethink that.

But don&#39;t lose momentum. Keep going! Every Little Project Gets Done... Next!


</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-05-01-post-16.md">FILE: ../pythonically/_posts/2022-05-01-post-16.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-05-01-post-16.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Writing a Bash Loop Script for Jekyll&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: writing-a-bash-loop-script-for-jekyll
permalink: /blog/writing-a-bash-loop-script-for-jekyll/
---

Editing 10 sites at once that are all actually in-play requires editing a lot
of files at once, quite often identical. So long as they are identical, I
should really centralize them. I can always break them into 10 different
individually managed files anytime I want. But until then, cross-cutting
changes will be a breeze. I&#39;m already using a &#34;helper&#34; repo for this purpose...
almost. I just need to carry through on the concept. Every little project gets
done! 1, 2, 3... 1?

List the files you&#39;ll be doing this with and put a copy in place.

- \_config.yml (will break much of MikeLev.in, but fix as you go)
- \_includes/youtubePlayer.html
- \_layouts/post.html
- assets/css/styles.scss

I&#39;ll even be able to do \_layouts/default.html once I understand how to break
out the Google Analytics ID with an include similar to the way I do the YouTube
wrapper, but it&#39;s one more layer lower in the rendering process so I have to
think it through. Go ahead with those other ones and keep a sharp eye om
MikeLev.in because it&#39;s so different from the others.

```bash
for SITE in MikeLevin pythonically whatsametafor linuxpythonvimgit mikeateleven tardigradecircus removablefinger mike-levin lundervand pipulate guerillatech
do
    rm ./$SITE/_posts/*
    cp ./helpers/_config.yml ./$SITE/
    cp ./helpers/style.scss ./$SITE/assets/css/
    cp ./helpers/post.html ./$SITE/_layouts/
    cp ./helpers/youtubePlayer.html ./$SITE/_includes/
done
```

Okay wow, that&#39;ll change things. Think! Ready, fire, aim! Why not? It&#39;s Sunday
morning and I have time to fix anything that breaks. Here&#39;s my entire current
release script, which I call gall.sh... LOL! I&#39;ve got some gall.

```bash
#    _     _           _
#  _| |__ | | __ _ ___| |_
# (_) &#39;_ \| |/ _` / __| __|
#  _| |_) | | (_| \__ \ |_
# (_)_.__/|_|\__,_|___/\__|

clear

for SITE in MikeLevin pythonically linuxpythonvimgit mikeateleven tardigradecircus removablefinger mike-levin lundervand pipulate whatsametafor guerillatech
do
    rm ./$SITE/_posts/*
    cp ./helpers/_config.yml ./$SITE/
    cp ./helpers/style.scss ./$SITE/assets/css/
    cp ./helpers/post.html ./$SITE/_layouts/
    cp ./helpers/youtubePlayer.html ./$SITE/_includes/
done

figlet slicing blogs...
cd blogslicer
nbdev_clean_nbs
nbdev_build_lib
git commit -am &#34;Updating all&#34;
git push

python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../MikeLevin&#34; -t &#34;Mike Levin&#39;s Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../pythonically&#34; -t &#34;Pythonic Ally Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../whatsametafor&#34; -t &#34;What&#39;s A Meta For Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../linuxpythonvimgit&#34; -t &#34;Linux, Python, vim &amp; git Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../mikeateleven&#34; -t &#34;Mike&#39;s At Eleven Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../tardigradecircus&#34; -t &#34;Tardigrade Circus Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../removablefinger&#34; -t &#34;Removable Finger Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../mike-levin&#34; -t &#34;Mike-Levin.com Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../lundervand&#34; -t &#34;Lunervand Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../pipulate&#34; -t &#34;Pipulate Blog&#34; -s &#34;blog&#34;
python ./blogslicer/core.py -a &#34;Mike Levin&#34; -p &#34;../guerillatech&#34; -t &#34;Guerilla Tech Blog&#34; -s &#34;blog&#34;
cd ..

figlet vim
cp ~/.vimrc ./vim/
cd ./vim
git commit -am &#34;Updating all&#34;
git push
cd ..

figlet helpers
cp ./all.sh ./helpers/
cp ./gall.sh ./helpers/
cp ./defaults.sh ./helpers/
cp ./homepages.sh ./helpers/
cp ./styles.sh ./helpers/
cd helpers
git commit -am &#34;Updating all&#34;
git push
cd ..

figlet journal
cd journal
git commit -am &#34;Updating all&#34;
git push
cd ..

figlet mikelevinseo -w 120
cd mlseo
jupyter nbconvert --to markdown index.ipynb
sed -i -e &#39;1,5d&#39; index.md
mv index.md ./docs
git add ./docs/*
git commit -am &#34;Updating all&#34;
git push
cd ..

for SITE in MikeLevin pythonically linuxpythonvimgit mikeateleven tardigradecircus removablefinger mike-levin lundervand pipulate whatsametafor guerillatech
do
    figlet $SITE -w 120
    cd $SITE
    git add _includes/*
    git add _posts/*
    git commit -am &#34;Updating all&#34;
    git push
    cd ..
done

figlet Done!
```

Okay, in my first testing of this capability, I&#39;m going to add some line-height
around my prev/next arrows by putting this:

    line-height: 3;

...into style.scss

Success! The URLs of my old MikeLev.in site didn&#39;t even break. Oh wow, this is
going to be nice.

Think through next steps. Every Little Project Gets Done!


</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-30-post-15.md">FILE: ../pythonically/_posts/2022-04-30-post-15.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-30-post-15.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Adding Style Sheets to Github Pages Jekyll Blog&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: adding-style-sheets-to-github-pages-jekyll-blog
permalink: /blog/adding-style-sheets-to-github-pages-jekyll-blog/
---

Okay, that was easy, adding the prev/next arrows to Jekyll blogs. But I&#39;m not
quite done. There&#39;s some CSS that completes the project.

It was a bit tricky to figure out. I don&#39;t normally do the sass css generators,
but it&#39;s built into Jekyll. The default css for Jekyll is the type of thing you
download and put in location locally just like a default.html or post.html. And
like them, there will be some transformations occurring, but instead of just
using a style.css you use a style.scss which does an import:

    ---
    ---

    @import &#39;jekyll-theme-hacker&#39;;

Using the CSS provided at the article I&#39;m working off of, I guessed that you
simply paste it underneath:

    ---
    ---

    @import &#39;jekyll-theme-hacker&#39;;

    .post-nav {
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
    }

    .post-nav p {
        flex: 1 1 0;
        width: 45%;
    }

    .post-nav p:first-child {
        padding-right: 0.5em;
    }

    .post-nav p:last-child {
        padding-left: 0.5em;
        text-align: right;
    }



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-30-post-14.md">FILE: ../pythonically/_posts/2022-04-30-post-14.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-30-post-14.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Adding Prev/Next Arrows to Github Pages Jekyll Blog Posts&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: adding-prev-next-arrows-to-github-pages-jekyll-blog-posts
permalink: /blog/adding-prev-next-arrows-to-github-pages-jekyll-blog-posts/
---

Hello, hello, hello! This is your Pythonic Ally again. The time has come the
walrus said to add previous/next links to the blog posts in the blog slice &amp;
dice system you just saw me create.

There are options for doing this (probably) in the Liquid template system that
Jekyll is built on. But since I&#39;m outputting these pages pythonically, I&#39;m
sitting on top of all the data I need right at the moment the files are
generated, so why not just put them directly in the markdown files? No need for
some templating system dependency!

Okay, good approach. Now think it through. This is a wonderful shining example
of why we keep our Python code both in a Jupyter Notebook and in a .py file. My
release system both creates and uses the .py file from the Notebook. I almost
never look at or think about the .py file that actually does the blog slicing
but it&#39;s always in sync with the Notebook version that I&#39;m always tweaking and
refining. Great workflow!

This is one such tweak.

It goes something like this:

Whenever we encounter the slicer-token (80 * &#34;-&#34;), we know to output the table
we must have just accumulated-up along with the date that we know to be in a
corresponding list of dates that we created from a prior spin-through. Actually
handling the dates was one of the more difficult parts of the blogslicer
project. The concept goes like this:

There is a slicer token above and below every blog post.

Therefore when spinning through a single-page-journal that&#39;s going to be sliced
&amp; diced into individual files, the first slicer-token encountered is a
throw-away one because it hasn&#39;t been &#34;accumulating up&#34; a blog post to that
point. However, on that first instance it is still important to grab the date
which it knows it&#39;s going to encounter on the next line. This slicer-token,
date-grab continues until the last slicer-token underneath of which there will
be no date. To make things easy, I just surround the attempts at date-grabs in
a try/except. That way the last slicer-token which has no date after it won&#39;t
generate an error.

Okay, so that&#39;s the system.

I had to do a loop ahead of time to know how many blog posts there are and so
the counter can count-down from the highest number down to 1. In this way, blog
posts will automatically always get the same title and URL if they have to be
auto-generated. So that first spin-through is necessary.

It&#39;s on the 2nd spin-through that title-logic is applied. Title logic can&#39;t be
moved to the 1st spin-through because that&#39;s what generates the requirements
for the 2nd spin-through. But without having the titles already on-hand, we
can&#39;t look-ahead to the next title, which is what would be necessary to create
the &#34;next&#34; arrow of a previous/next blog post navigator system.

It looks like we&#39;ll be doing a THIRD spin-through. This complexity may argue
for using what&#39;s built into Jekyll. Let me see if their blog posting system
accommodates for arrows. If not, I&#39;ll be doing a 3rd spin-through and appending
the arrows to the bottom of each blog-post file for sure. Not the biggest deal,
but investigate Jekyll post system first.

Here&#39;s a wonderful article that focuses on a CSS feature called flexbox:

[ByteDude&#39;s Jekyll blog post prev/next arrows](https://www.bytedude.com/jekyll-previous-and-next-posts/)

Me detects lots of rabbit-hole issues here. I haven&#39;t even thought about
formatting the prev/next arrows I was planning on &#34;manually&#34; inserting with
Python, and that&#39;s a point which the canned solutions cover well. So why not
just use the canned solution?

The only reason I can think why not is that I don&#39;t know how to override the
blog post template. But it couldn&#39;t be different than the normal page template,
right? I hope it won&#39;t make me have to add my Google Analytics code all over
again. Hopefully it&#39;s a nested or compositing or inheriting system... whatever
language you want to put on &#34;inner&#34; modifications not having to re-create all
the &#34;outer&#34; wrapper customizations. The outer-wrapper stuff of
\_layouts\default.html should still apply.

So I go to Github Hacker theme page [Github Pages Hacker Theme](https://github.com/pages-themes/hacker)

I grab the raw code at: [Raw Hacker Post Theme](https://raw.githubusercontent.com/pages-themes/hacker/master/_layouts/post.html)

I drop it into /github/pythonically/\_layouts and add it to the repo.

I edit out the code that adds tags, which I don&#39;t sue anyway. Commit and
push...

Okay, that worked. But I noticed another problem that the default title/url
that&#39;s created if there&#39;s no title explicitly set is causing a 404. I don&#39;t
know if it&#39;s a content issue or a blogslicer issue. Ugh! Nothing informative is
available anywhere to debug.

Oh, my bad! I just did a fast-track git commit/push without using my release
script which actually does all the blog slice &amp; dice work. Without using the
release script, links are bound to be broken. Remember that. Okay, the
\_layouts\post.html is doing its job exactly as hoped, meaning that the Google
Analytics tag manager code that I add with \_layouts/default.html are still
being applied. This is a compositing system. Excellent! Good work Jekyll on
that. So next step? Drop in the code from the article!

@g

...wait... Refresh... Yes! Success! Just that easy!

But I don&#39;t have the CSS yet. Hmmm. Well, I want to copy this file into
location for each of my sites.

Use my itersites.py file in /github/helpers/ to copy the post.html into
\_layouts, git add and git commit... okay, done.

Do a release and get at least some barebones (unformatted with CSS) prev/next
arrows propagated all over the place...



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-29-post-13.md">FILE: ../pythonically/_posts/2022-04-29-post-13.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-29-post-13.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Stop Using Stop-Words When They Reverse Meaning&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: stop-using-stop-words-when-they-reverse-meaning
permalink: /blog/stop-using-stop-words-when-they-reverse-meaning/
---

Ugh, after all that stopwords stuff from the earlier post, I&#39;m stripping it
out. The meaning can get totally mangled. For example, the title:

    Don’t Obfuscate A Perfectly Fine Pythonic FizzBuzz

...became the URL:

    https://pythonically.com/blog/obfuscate-perfectly-fine-pythonic-fizzbuzz/

Ugh! Unacceptable! Okay, so I stripped out all that stop_words stuff, and the
code is now:

```python
# export

import nltk
import argparse
from pathlib import Path
from dateutil import parser
from slugify import slugify


if hasattr(__builtins__, &#34;__IPYTHON__&#34;):
    from IPython.display import display, Markdown

    h1 = lambda text: display(Markdown(f&#34;# {text}&#34;))
    h2 = lambda text: display(Markdown(f&#34;## {text}&#34;))
    h3 = lambda text: display(Markdown(f&#34;### {text}&#34;))

    folder_name = &#34;../pythonically&#34;
    blog_title = &#34;Pythonic Ally Blog&#34;
    blog_slug = &#34;blog&#34;
else:
    h1 = lambda text: print(f&#34;# {text}&#34;)
    h2 = lambda text: print(f&#34;## {text}&#34;)
    h3 = lambda text: print(f&#34;## {text}&#34;)

    aparser = argparse.ArgumentParser()
    add_arg = aparser.add_argument
    add_arg(&#34;-p&#34;, &#34;--path&#34;, required=True)
    add_arg(&#34;-t&#34;, &#34;--title&#34;, required=True)
    add_arg(&#34;-s&#34;, &#34;--slug&#34;, required=True)
    args = aparser.parse_args()

    folder_name = args.path
    blog_title = args.title
    blog_slug = args.slug


index_front_matter = f&#34;&#34;&#34;---
layout: post
title: &#34;{blog_title}&#34;
slug: {blog_slug}
---

### [{blog_title} as One Page](/journal/)

&#34;&#34;&#34;

journal_path = f&#34;{folder_name}/journal.md&#34;
output_path = f&#34;{folder_name}/_posts/&#34;
slicer = &#34;-&#34; * 80

Path(output_path).mkdir(exist_ok=True)

dates = []
counter = -1
date_next = False
with open(journal_path, &#34;r&#34;) as fh:
    for line in fh:
        line = line.rstrip()
        if date_next:
            adate = line[3:]
            date_next = False
            adatetime = parser.parse(adate).date()
            dates.append(adatetime)
            date_next = False
        if line == slicer:
            date_next = True
            counter = counter + 1
dates.reverse()

table = []
at_top = True
index_list = []
with open(journal_path, &#34;r&#34;) as fh:
    for i, line in enumerate(fh):
        line = line.rstrip()
        if line == slicer:
            if at_top:
                at_top = False
                table = []
                continue
            adatetime = dates[counter - 1]
            filename = f&#34;{output_path}{adatetime}-post-{counter}.md&#34;
            h3(f&#34;FILE: {filename}&#34;)
            with open(filename, &#34;w&#34;) as fw:
                title = f&#34;Post {counter}&#34;
                slug = title
                if table[0] == slicer:
                    table = table[1:]
                maybe = table[1]
                has_title = False
                if table and maybe and maybe[0] == &#34;#&#34;:
                    title = maybe[maybe.find(&#34; &#34;) + 1 :]
                    has_title = True
                slug = slugify(title)
                top = []
                top.append(&#34;---\n&#34;)
                top.append(&#34;layout: post\n&#34;)
                top.append(f&#39;title: &#34;{title}&#34;\n&#39;)
                top.append(f&#34;categories: {blog_slug}\n&#34;)
                top.append(f&#34;slug: {slug}\n&#34;)
                link = f&#34;- [{title}](/{blog_slug}/{slug}/)&#34;
                index_list.append(link)
                top.append(&#34;---\n&#34;)
                top.append(&#34;\n&#34;)
                top_chop = 2
                if has_title:
                    top_chop = 3
                table = [f&#34;{x}\n&#34; for x in table[top_chop:]]
                table = top + table
                print(&#34;&#34;.join(table))
                fw.writelines(table)
            counter = counter - 1
            table = []
        table.append(line)

index_page = index_front_matter + &#34;\n\n&#34; + &#34;\n&#34;.join(index_list)

with open(f&#34;{folder_name}/blog.md&#34;, &#34;w&#34;) as fh:
    fh.writelines(index_page)
```



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-29-post-12.md">FILE: ../pythonically/_posts/2022-04-29-post-12.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-29-post-12.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Massaging 10 Sites Into Shape At Once&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: massaging-10-sites-into-shape-at-once
permalink: /blog/massaging-10-sites-into-shape-at-once/
---

Okay, I just removed stopwords from Jekyll blog post URLs. I did it quite
easily borrowing some code I recently did for [mlseo](https://pypi.org/project/mlseo/).
And next I think I want to roll the advances out across all my sites that could
benefit. Okay, so do it!

I just did whatsametafor.io. There were some interesting steps that I have to
remember:

- git mv index.md journal.md
- Put a new index.md in location
- Update the \_config.yml file

Do https://linuxpythonvimgit.com/ next and update that check-list. Also instead
of venturing into all these different Github.io templates (a mistake) focus on
one single template (hacker) so that you can move forward across all sites more
rapidly. Sure, they&#39;ll all look the same at first, but I can focus later on
divergence. It&#39;s convergence right now that accelerates the process.

Okay so let&#39;s do this thing.

- cd into ~/github/linuxpythonvimgit
- git mv index.md journal.md
- cp ../whatsametafor/index.md .
- Edits to index.md
- git add index.md
- mkdir \_posts

Ugh! Do this for every folder at once. Okay, so I put some &#34;source&#34; files into
my helper folder, such as a sample \_config.yml and index.md file. Then I
execute this script from Linux on Windows. Because of the use of git in the
commands, it is not an appropriate script to run from JuptyerLabs on Windows.

```python
from subprocess import run
from pathlib import Path


sites = &#34;&#34;&#34;guerillatech
linuxpythonvimgit
lundervand
mike-levin
mikeateleven
pipulate
pythonically
removablefinger
tardigradecircus
tictacufosightings
whatsametafor&#34;&#34;&#34;.split(&#39;\n&#39;)

ghp = &#34;/mnt/c/Users/mikle/github/&#34;

for site in sites:
    Path(f&#39;../{site}/_posts&#39;).mkdir(exist_ok=True)
    print(site)
    if not Path(f&#34;{ghp}{site}/index.md&#34;).is_file():
        run([&#34;cp&#34;, &#34;index.md&#34;, f&#34;{ghp}{site}/&#34;], cwd=f&#34;{ghp}helpers/&#34;)
    run([&#34;git&#34;, &#34;add&#34;, &#34;_posts&#34;], cwd=f&#34;{ghp}{site}/&#34;)
    run([&#34;git&#34;, &#34;add&#34;, &#34;blog.md&#34;], cwd=f&#34;{ghp}{site}/&#34;)
    run([&#34;git&#34;, &#34;add&#34;, &#34;index.md&#34;], cwd=f&#34;{ghp}{site}/&#34;)
    run([&#34;cp&#34;, &#34;_config.yml&#34;, f&#34;{ghp}{site}/&#34;], cwd=f&#34;{ghp}helpers/&#34;)
    run([&#34;git&#34;, &#34;add&#34;, &#34;_config.yml&#34;], cwd=f&#34;{ghp}{site}/&#34;)
    run([&#34;git&#34;, &#34;commit&#34;, &#34;-am&#34;, &#34;Added _posts&#34;], cwd=f&#34;{ghp}{site}/&#34;)
    print()
```


</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-29-post-11.md">FILE: ../pythonically/_posts/2022-04-29-post-11.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-29-post-11.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Removing Stopwords From Jekyll Blog URLs&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: removing-stopwords-from-jekyll-blog-urls
permalink: /blog/removing-stopwords-from-jekyll-blog-urls/
---

Yesterday I got the must-have features of my blogslicer program done. It can be
found in github as [blogslicer](https://github.com/miklevin/blogslicer/). This
is actually rather big in my life and one of the perfect &#34;because I&#39;m 50&#34;
projects. It&#39;s the first of my ELPGD (every little project gets done)
mentality. Honestly, I&#39;ve spent the last 15 years or so just re-educating
myself and getting tech-literate again.

- I once was tech-literate because of the Amiga computer. Then it went away.
- I again was tech-literate because of Microsoft Active Server Pages. Then it
  went away.
- I was fooled twice and refused to get fooled again.
  - So I passed over Ruby on Rails
  - So I passed over JavaScript on the server
- After long soul-searching, I settled on:
  - Linux
  - Python
  - vim
  - git

And I never looked back... oh, except when JavaScript took over the world as
&#34;the full webstack&#34;. Then I looked back, had buyer&#39;s remorse, looked more
closely at JavaScript and ECMA script, then was happy with my LPvg (Linux,
Python, vim &amp; git) decision. Ugh! I see the hamster wheel JavaScript folks are
on today and I see it as the institutionalization of the very tech-reset-button
I despise. Even if your core language stays the same, it&#39;s just as bad if the
core language is awful and all the frameworks based on it (out of necessity)
are both equally awful and constantly changing.

If I need a web-service (or web-anything, for that matter) there&#39;s Flask. There
always was Flask. There always will be Flask. And while there are many others
like FastAPI, pylons and the like, they&#39;re all optional higher-dependency
fad-driven edge cases that come and go. Flask always remains. It&#39;s too big to
fail and too widely deployed to not be upgraded. We see that in its embracing
of async/await... though the same can&#39;t be said of the ubiquitous Requests
package. But the point almost still stands because httpx came along as an
API-compatible version of Requests that does support async/await, so you don&#39;t
really have to relearn old stuff. You can just focus on the new. And when
Request finally does come around, chances are its implementation will be
similar enough to httpx that your career of computer literacy won&#39;t be nuked
the way it is in a move from React to Vue or from Vue to Svelte or whatnot.

Okay, all that&#39;s just sort of a deep-breath preamble to what I want to do next
on blogslicer. URLs are too long. I need to filter stop-words out of the URLs
when a custom URL is constructed from the title. This is instead of
implementing some arbitrary plug/slug replacement system. If you&#39;re basing URLs
on titles then you&#39;re basing URLs on titles. Most of the things you&#39;d want to
overwrite that for is editing out stopwords anyway. And so...

```python
import nltk
from nltk.corpus import stopwords

nltk.download(&#34;stopwords&#34;, quiet=True)
stops = stopwords.words(&#34;english&#34;)
...
slug = title.lower()
slug = &#34; &#34;.join([x for x in slug.split() if x not in stops])
```

Yup. And so now incorporate it into the code:

```python
# export

import nltk
import argparse
from dateutil import parser
from slugify import slugify
from nltk.corpus import stopwords

nltk.download(&#34;stopwords&#34;, quiet=True)
stops = stopwords.words(&#34;english&#34;)

if hasattr(__builtins__, &#34;__IPYTHON__&#34;):
    from IPython.display import display, Markdown

    h1 = lambda text: display(Markdown(f&#34;# {text}&#34;))
    h2 = lambda text: display(Markdown(f&#34;## {text}&#34;))
    h3 = lambda text: display(Markdown(f&#34;### {text}&#34;))

    folder_name = &#34;../pythonically&#34;
    blog_title = &#34;Pythonic Ally Blog Index&#34;
    blog_slug = &#34;blog&#34;
else:
    h1 = lambda text: print(f&#34;# {text}&#34;)
    h2 = lambda text: print(f&#34;## {text}&#34;)
    h3 = lambda text: print(f&#34;## {text}&#34;)

    aparser = argparse.ArgumentParser()
    add_arg = aparser.add_argument
    add_arg(&#34;-p&#34;, &#34;--path&#34;, required=True)
    add_arg(&#34;-t&#34;, &#34;--title&#34;, required=True)
    add_arg(&#34;-s&#34;, &#34;--slug&#34;, required=True)
    args = aparser.parse_args()

    folder_name = args.path
    blog_title = args.title
    blog_slug = args.slug


index_front_matter = f&#34;&#34;&#34;---
layout: post
title: &#34;{blog_title}&#34;
slug: {blog_slug}
---&#34;&#34;&#34;

journal_path = f&#34;{folder_name}/journal.md&#34;
output_path = f&#34;{folder_name}/_posts/&#34;
slicer = &#34;-&#34; * 80

dates = []
counter = -1
date_next = False
with open(journal_path, &#34;r&#34;) as fh:
    for line in fh:
        line = line.rstrip()
        if date_next:
            adate = line[3:]
            date_next = False
            adatetime = parser.parse(adate).date()
            dates.append(adatetime)
            date_next = False
        if line == slicer:
            date_next = True
            counter = counter + 1
dates.reverse()

h1(f&#34;There Are {counter} Posts:&#34;)

table = []
at_top = True
index_list = []
with open(journal_path, &#34;r&#34;) as fh:
    for i, line in enumerate(fh):
        line = line.rstrip()
        if line == slicer:
            if at_top:
                at_top = False
                table = []
                continue
            adatetime = dates[counter - 1]
            filename = f&#34;{output_path}{adatetime}-post-{counter}.md&#34;
            h3(f&#34;FILE: {filename}&#34;)
            with open(filename, &#34;w&#34;) as fw:
                title = f&#34;Post {counter}&#34;
                slug = title
                if table[0] == slicer:
                    table = table[1:]
                maybe = table[1]
                has_title = False
                if table and maybe and maybe[0] == &#34;#&#34;:
                    title = maybe[maybe.find(&#34; &#34;) + 1 :]
                    has_title = True
                slug = title.lower()
                slug = &#34; &#34;.join([x for x in slug.split() if x not in stops])
                slug = slugify(slug)
                top = []
                top.append(&#34;---\n&#34;)
                top.append(&#34;layout: post\n&#34;)
                top.append(f&#39;title: &#34;{title}&#34;\n&#39;)
                top.append(f&#34;categories: {blog_slug}\n&#34;)
                top.append(f&#34;slug: {slug}\n&#34;)
                link = f&#34;- [{title}](/{blog_slug}/{slug}/)&#34;
                index_list.append(link)
                top.append(&#34;---\n&#34;)
                top.append(&#34;\n&#34;)
                top_chop = 2
                if has_title:
                    top_chop = 3
                table = [f&#34;{x}\n&#34; for x in table[top_chop:]]
                table = top + table
                print(&#34;&#34;.join(table))
                fw.writelines(table)
            counter = counter - 1
            table = []
        table.append(line)

index_page = index_front_matter + &#34;\n\n&#34; + &#34;\n&#34;.join(index_list)

with open(f&#34;{folder_name}/blog.md&#34;, &#34;w&#34;) as fh:
    fh.writelines(index_page)
```

It&#39;s time to look into how to highlight specific lines of code in markdown
under Jekyll.



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-28-post-10.md">FILE: ../pythonically/_posts/2022-04-28-post-10.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-28-post-10.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Adding Command-Line Argument Support to Jupyter Notebook&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: adding-command-line-argument-support-to-jupyter-notebook
permalink: /blog/adding-command-line-argument-support-to-jupyter-notebook/
---

The time has come the walrus said to parameterize blogslicer. Running it in a
notebook is dandy, but incorporating it into my regular release process is
better. And my release process is a bash shell script.

Everyone should use bash shell scripts even if you&#39;re on Windows (as I am) or
Mac because it&#39;s one of those timeless skills that transcends all else in tech.

In case you didn&#39;t notice, tech is text and text is tricks. And so by the
transitive property of because-I-say-so, all tech is tricks. And by far one of
the greatest of all tricks is to take something you&#39;ve developed in a Jupyter
Notebook which could apply to a whole host of different situations and to turn
it into a parameterized package.

Huh? Yeah, that just means making the file.ipynb into a file.py and make sure
you can send it input-values on the command-line string. Sometimes these are
called parameters. And the parameters take arguments. Parameters have rules
like whether labeling the input with keywords is necessary or whether absolute
positions after the file.py have special meaning, such as:

```bash
blogslicer.py -foo bar
```

And so what we do is look at the Python standard library and find argparse. And
after years of shunning pip installs for something the standard library did
perfectly well, I&#39;m doing a complete 180. Most people will guide you towards
docopt (best package name ***ever***) or click. After a thorough cheerleading
session by Cecil Phillip on the [Talk Python to Me](https://talkpython.fm/episodes/show/363/python-for-.net-and-c-developers)
podcast, I&#39;m going to give Typer a try.

I&#39;m actually quite new to the Python mypy optional type annotation system which
typer seems to use, so this may be a new experience for me. I may have to add
type annotations to blogslicer, which will make this a doubly interesting
project. Okay, so 1, 2, 3... 1?

```python
pip install typer
```

The example at https://typer.tiangolo.com/ says... oh, boooo! This thing seems
to actually require the use of functions. Darn it! That&#39;s the thing about these
snooty right-way-to-do-things opinionated apps. Shoot, I was looking forward to
it too.

So do I change this journal entry? Nope! The process is as insightful as
anything else. So let me remind myself what it&#39;d look like with argparse.

```python
import argparse

parser = argparse.ArgumentParser()
add_arg = parser.add_argument
add_arg(&#34;-p&#34;, &#34;--path&#34;, required=True)
add_arg(&#34;-t&#34;, &#34;--title&#34;, required=True)
add_arg(&#34;-s&#34;, &#34;--slug&#34;, required=True)
args = parser.parse_args()
```

This is all well and good, but it won&#39;t run in a Jupyter Notebook. Okay, so I
need to create another Notebook as a test. I don&#39;t want to mix this in with the
good code yet. I&#39;m isolating a test:

```python
# export

if hasattr(__builtins__, &#34;__IPYTHON__&#34;):
    folder_name = &#34;../pythonically&#34;
    blog_title = &#34;Pythonic Ally Blog Index&#34;
    blog_slug = &#34;blog&#34;
else:
    import argparse

    parser = argparse.ArgumentParser()
    add_arg = parser.add_argument
    add_arg(&#34;-p&#34;, &#34;--path&#34;, required=True)
    add_arg(&#34;-t&#34;, &#34;--title&#34;, required=True)
    add_arg(&#34;-s&#34;, &#34;--slug&#34;, required=True)
    args = parser.parse_args()
    print(args)

    folder_name = args.path
    blog_title = args.title
    blog_slug = args.slug

print(folder_name, blog_title, blog_slug)
```

You will notice the export command at the top. That&#39;s for nbdev. There&#39;s also
another code-block in the notebook which sets the default file-name. The point
is here that I can use notebooks even to code up .py files that are not going
to run in the context of Jupyter. I use nbdev_build_lib which outputs the file.
And I test it like this:

```bash
python testargs.py -p &#34;./pythonically&#34; -t &#34;This is my title&#34; -s &#34;blog&#34;
./pythonically This is my title blog
```

And that is what we call a massive success! DocOpt? Click? Typer? Pishaw! Who
needs them. I&#39;ve reverted to my old belief that the good ol&#39; standard library
is arguably good enough for arguments.

And so now it&#39;s time to transplant my test code into blogslicer!

```python
# export

import dateutil
from slugify import slugify


try:
    from IPython.display import display, Markdown

    h1 = lambda text: display(Markdown(f&#34;# {text}&#34;))
    h2 = lambda text: display(Markdown(f&#34;## {text}&#34;))
    h3 = lambda text: display(Markdown(f&#34;### {text}&#34;))
    jn = True
except:
    h1 = lambda text: print(f&#34;# {text}&#34;)
    h2 = lambda text: print(f&#34;## {text}&#34;)
    h3 = lambda text: print(f&#34;## {text}&#34;)
    jn = False

if hasattr(__builtins__, &#34;__IPYTHON__&#34;):
    folder_name = &#34;../pythonically&#34;
    blog_title = &#34;Pythonic Ally Blog Index&#34;
    blog_slug = &#34;blog&#34;
else:
    import argparse

    parser = argparse.ArgumentParser()
    add_arg = parser.add_argument
    add_arg(&#34;-p&#34;, &#34;--path&#34;, required=True)
    add_arg(&#34;-t&#34;, &#34;--title&#34;, required=True)
    add_arg(&#34;-s&#34;, &#34;--slug&#34;, required=True)
    args = parser.parse_args()

    folder_name = args.path
    blog_title = args.title
    blog_slug = args.slug

index_front_matter = f&#34;&#34;&#34;---
layout: post
title: &#34;{blog_title}&#34;
slug: {blog_slug}
---&#34;&#34;&#34;

journal_path = f&#34;{folder_name}/journal.md&#34;
output_path = f&#34;{folder_name}/_posts/&#34;
slicer = &#34;-&#34; * 80

dates = []
counter = -1
date_next = False
with open(journal_path, &#34;r&#34;) as fh:
    for line in fh:
        line = line.rstrip()
        if date_next:
            adate = line[3:]
            date_next = False
            adatetime = dateutil.parser.parse(adate).date()
            dates.append(adatetime)
            date_next = False
        if line == slicer:
            date_next = True
            counter = counter + 1
dates.reverse()

h1(f&#34;There Are {counter} Posts:&#34;)

table = []
at_top = True
index_list = []
with open(journal_path, &#34;r&#34;) as fh:
    for i, line in enumerate(fh):
        line = line.rstrip()
        if line == slicer:
            if at_top:
                at_top = False
                table = []
                continue
            adatetime = dates[counter - 1]
            filename = f&#34;{output_path}{adatetime}-post-{counter}.md&#34;
            h3(f&#34;FILE: {filename}&#34;)
            with open(filename, &#34;w&#34;) as fw:
                title = f&#34;Post {counter}&#34;
                slug = title
                if table[0] == slicer:
                    table = table[1:]
                maybe = table[1]
                has_title = False
                if table and maybe and maybe[0] == &#34;#&#34;:
                    title = maybe[maybe.find(&#34; &#34;) + 1 :]
                    has_title = True
                slug = slugify(title)
                top = []
                top.append(&#34;---\n&#34;)
                top.append(&#34;layout: post\n&#34;)
                top.append(f&#39;title: &#34;{title}&#34;\n&#39;)
                top.append(f&#34;categories: {blog_slug}\n&#34;)
                top.append(f&#34;slug: {slug}\n&#34;)
                link = f&#34;- [{title}](/{blog_slug}/{slug}/)&#34;
                index_list.append(link)
                top.append(&#34;---\n&#34;)
                top.append(&#34;\n&#34;)
                top_chop = 2
                if has_title:
                    top_chop = 3
                table = [f&#34;{x}\n&#34; for x in table[top_chop:]]
                table = top + table
                print(&#34;&#34;.join(table))
                fw.writelines(table)
            counter = counter - 1
            table = []
        table.append(line)

index_page = index_front_matter + &#34;\n\n&#34; + &#34;\n&#34;.join(index_list)

with open(f&#34;{folder_name}/blog.md&#34;, &#34;w&#34;) as fh:
    fh.writelines(index_page)
```

Okay, but I see that I have 2 different places (and techniques) where I test
whether it&#39;s running in a Notebook or not. I should combine them as such:

```python
# export

import argparse
from dateutil import parser
from slugify import slugify


if hasattr(__builtins__, &#34;__IPYTHON__&#34;):
    from IPython.display import display, Markdown

    h1 = lambda text: display(Markdown(f&#34;# {text}&#34;))
    h2 = lambda text: display(Markdown(f&#34;## {text}&#34;))
    h3 = lambda text: display(Markdown(f&#34;### {text}&#34;))

    folder_name = &#34;../pythonically&#34;
    blog_title = &#34;Pythonic Ally Blog Index&#34;
    blog_slug = &#34;blog&#34;
else:
    h1 = lambda text: print(f&#34;# {text}&#34;)
    h2 = lambda text: print(f&#34;## {text}&#34;)
    h3 = lambda text: print(f&#34;## {text}&#34;)

    aparser = argparse.ArgumentParser()
    add_arg = aparser.add_argument
    add_arg(&#34;-p&#34;, &#34;--path&#34;, required=True)
    add_arg(&#34;-t&#34;, &#34;--title&#34;, required=True)
    add_arg(&#34;-s&#34;, &#34;--slug&#34;, required=True)
    args = aparser.parse_args()

    folder_name = args.path
    blog_title = args.title
    blog_slug = args.slug


index_front_matter = f&#34;&#34;&#34;---
layout: post
title: &#34;{blog_title}&#34;
slug: {blog_slug}
---&#34;&#34;&#34;

journal_path = f&#34;{folder_name}/journal.md&#34;
output_path = f&#34;{folder_name}/_posts/&#34;
slicer = &#34;-&#34; * 80

dates = []
counter = -1
date_next = False
with open(journal_path, &#34;r&#34;) as fh:
    for line in fh:
        line = line.rstrip()
        if date_next:
            adate = line[3:]
            date_next = False
            adatetime = parser.parse(adate).date()
            dates.append(adatetime)
            date_next = False
        if line == slicer:
            date_next = True
            counter = counter + 1
dates.reverse()

h1(f&#34;There Are {counter} Posts:&#34;)

table = []
at_top = True
index_list = []
with open(journal_path, &#34;r&#34;) as fh:
    for i, line in enumerate(fh):
        line = line.rstrip()
        if line == slicer:
            if at_top:
                at_top = False
                table = []
                continue
            adatetime = dates[counter - 1]
            filename = f&#34;{output_path}{adatetime}-post-{counter}.md&#34;
            h3(f&#34;FILE: {filename}&#34;)
            with open(filename, &#34;w&#34;) as fw:
                title = f&#34;Post {counter}&#34;
                slug = title
                if table[0] == slicer:
                    table = table[1:]
                maybe = table[1]
                has_title = False
                if table and maybe and maybe[0] == &#34;#&#34;:
                    title = maybe[maybe.find(&#34; &#34;) + 1 :]
                    has_title = True
                slug = slugify(title)
                top = []
                top.append(&#34;---\n&#34;)
                top.append(&#34;layout: post\n&#34;)
                top.append(f&#39;title: &#34;{title}&#34;\n&#39;)
                top.append(f&#34;categories: {blog_slug}\n&#34;)
                top.append(f&#34;slug: {slug}\n&#34;)
                link = f&#34;- [{title}](/{blog_slug}/{slug}/)&#34;
                index_list.append(link)
                top.append(&#34;---\n&#34;)
                top.append(&#34;\n&#34;)
                top_chop = 2
                if has_title:
                    top_chop = 3
                table = [f&#34;{x}\n&#34; for x in table[top_chop:]]
                table = top + table
                print(&#34;&#34;.join(table))
                fw.writelines(table)
            counter = counter - 1
            table = []
        table.append(line)

index_page = index_front_matter + &#34;\n\n&#34; + &#34;\n&#34;.join(index_list)

with open(f&#34;{folder_name}/blog.md&#34;, &#34;w&#34;) as fh:
    fh.writelines(index_page)
```

Pshwew! Okay, I think I&#39;ve got it. Now after I nbdev_build_lib, I can run this
on the command-line after cd&#39;ing into the blogslider/blogslicer subfolder that
nbdev creates.

```bash
python core.py -p &#34;../../pythonically&#34; -t &#34;Pythonic Ally Blog&#34; -s &#34;blog&#34;
```

And it worked! It output the sliced &amp; diced files into the correct Jekyll
\_posts folder, and so I am ready to incorporate this into my regular
publishing release script. I&#39;m tempted to put blogslicer into PyPi.org right
away, but there&#39;s no need so long as I can wrangle my paths correctly.

And it worked! I know because you&#39;re reading this as a result of me
incorporating the whole process into my regular release system.

What regular release system? Oh, the one that runs whenever I&#39;m blogging in vim
and press my @g macro... like I did just now. I won&#39;t overload this post with
my entire release script, but the part that publishes this site looks like
this:

```bash
figlet pythonically -w 120
python ./blogslicer/blogslicer/core.py -p &#34;./pythonically&#34; -t &#34;Pythonic Ally Blog&#34; -s &#34;blog&#34;
cd pythonically
# git pull
git add _includes/*
git add _posts/*
git commit -am &#34;Updating all&#34;
git push
cd ..
```

And so the world has changed forever for me with one little incremental step
forward.


</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-28-post-9.md">FILE: ../pythonically/_posts/2022-04-28-post-9.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-28-post-9.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Don&#39;t Obfuscate A Perfectly Fine Pythonic FizzBuzz&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: don-t-obfuscate-a-perfectly-fine-pythonic-fizzbuzz
permalink: /blog/don-t-obfuscate-a-perfectly-fine-pythonic-fizzbuzz/
---

Do you know FizzBuzz? If you&#39;re here, you probably do. But did you know that
you don&#39;t have to check whether the result of the modulo operator in Python
equals zero? In Python 0 evaluates false. Someone&#39;s gotta read The Hitchhiker&#39;s
Guide to Python.

So here&#39;s the FizzBuzz that you should know and love. Yes, there are other
ways. But what are you doing, entering a PERL obfuscation contest? Readability
counts! So impress your interviewer by knowing that this:

```python
for i in range(1, 101):
    if i % 3 == 0 and i % 5 == 0:
        print(&#34;FizzBuzz&#34;)
    elif i % 3 == 0:
        print(&#34;Fizz&#34;)
    elif i % 5 == 0:
        print(&#34;Buzz&#34;)
    else:
        print(i)
```

...is the same as this:

```python
for i in range(1, 101):
    if not i % 3 and not i % 5:
        print(&#34;FizzBuzz&#34;)
    elif not i % 3:
        print(&#34;Fizz&#34;)
    elif not i % 5:
        print(&#34;Buzz&#34;)
    else:
        print(i)
```

You might not think so, but this is of endless use in any situation where you
have to do something on the first iteration of a loop but not the subsequent
iterations. Sure you can check if i == 0 but isn&#39;t this cleaner?

```python
for i in range(10):
    if not i:
        print(f&#39;{i} is first&#39;)
```

And if you really must obfuscate it, at least do it in a Pythonic and
memory-efficient way:

```python
for i in range(1, 101):
    if not all((i % x for x in (3, 5))):
        print(&#34;FizzBuzz&#34;)
    elif not i % 3:
        print(&#34;Fizz&#34;)
    elif not i % 5:
        print(&#34;Buzz&#34;)
    else:
        print(i)
```

Readability counts! If some snotty Reddit HackerNews StackOverflow snot trys to
show you something involving importing packages or lambda commands, tell them
to:

```python
import this
```



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-27-post-8.md">FILE: ../pythonically/_posts/2022-04-27-post-8.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-27-post-8.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Creating Blog Index Page for Jekyll&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: creating-blog-index-page-for-jekyll
permalink: /blog/creating-blog-index-page-for-jekyll/
---

Jekyll has a way of creating index pages to expose links to the blog posts.


```python
import dateutil
from slugify import slugify


try:
    from IPython.display import display, Markdown

    h1 = lambda text: display(Markdown(f&#34;# {text}&#34;))
    h2 = lambda text: display(Markdown(f&#34;## {text}&#34;))
    h3 = lambda text: display(Markdown(f&#34;### {text}&#34;))
    jn = True
except:
    h1 = lambda text: print(f&#34;# {text}&#34;)
    h2 = lambda text: print(f&#34;## {text}&#34;)
    h3 = lambda text: print(f&#34;## {text}&#34;)
    jn = False

folder_name = &#34;../pythonically&#34;
blog = &#34;blog&#34;

index_front_matter = f&#34;&#34;&#34;---
layout: post
title: &#34;Pythonic Ally Blog Index&#34;
slug: {blog}
---&#34;&#34;&#34;

journal_path = f&#34;{folder_name}/journal.md&#34;
output_path = f&#34;{folder_name}/_posts/&#34;
slicer = &#34;-&#34; * 80

dates = []
counter = -1
date_next = False
with open(journal_path, &#34;r&#34;) as fh:
    for line in fh:
        line = line.rstrip()
        if date_next:
            adate = line[3:]
            date_next = False
            adatetime = dateutil.parser.parse(adate).date()
            dates.append(adatetime)
            date_next = False
        if line == slicer:
            date_next = True
            counter = counter + 1
dates.reverse()

h1(f&#34;There Are {counter} Posts:&#34;)

table = []
at_top = True
index_list = []
with open(journal_path, &#34;r&#34;) as fh:
    for i, line in enumerate(fh):
        line = line.rstrip()
        if line == slicer:
            if at_top:
                at_top = False
                table = []
                continue
            adatetime = dates[counter - 1]
            filename = f&#34;{output_path}{adatetime}-post-{counter}.md&#34;
            h3(f&#34;FILE: {filename}&#34;)
            with open(filename, &#34;w&#34;) as fw:
                title = f&#34;Post {counter}&#34;
                slug = title
                if table[0] == slicer:
                    table = table[1:]
                maybe = table[1]
                has_title = False
                if table and maybe and maybe[0] == &#34;#&#34;:
                    title = maybe[maybe.find(&#34; &#34;) + 1 :]
                    has_title = True
                slug = slugify(title)
                top = []
                top.append(&#34;---\n&#34;)
                top.append(&#34;layout: post\n&#34;)
                top.append(f&#39;title: &#34;{title}&#34;\n&#39;)
                top.append(f&#34;categories: {blog}\n&#34;)
                top.append(f&#34;slug: {slug}\n&#34;)
                link = f&#34;- [{title}](/{blog}/{slug}/)&#34;
                index_list.append(link)
                top.append(&#34;---\n&#34;)
                top.append(&#34;\n&#34;)
                top_chop = 2
                if has_title:
                    top_chop = 3
                table = [f&#34;{x}\n&#34; for x in table[top_chop:]]
                table = top + table
                print(&#34;&#34;.join(table))
                fw.writelines(table)
            counter = counter - 1
            table = []
        table.append(line)

index_page = index_front_matter + &#34;\n\n&#34; + &#34;\n&#34;.join(index_list)

with open(f&#34;{folder_name}/blog.md&#34;, &#34;w&#34;) as fh:
    fh.writelines(index_page)
```



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-27-post-7.md">FILE: ../pythonically/_posts/2022-04-27-post-7.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-27-post-7.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Every Little Project Gets Done (ELPGD)&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: every-little-project-gets-done-elpgd
permalink: /blog/every-little-project-gets-done-elpgd/
---

Okay, I did such good work on this blogslicer app. It&#39;s working in a repo
folder side-by-side with other repo folders, which is very important. It&#39;s easy
to get stuff to work relative to files within the same folder. But to get
something to step up **out** of its own folder, **over** and into another
folder and to work there doesn&#39;t always go as smoothly.

This is an important project for me because it opens the doors to the next and
the next project. It&#39;s an example of ELPID (every little project is doable). If
you can imagine it, it can get done... of course within a certain reason. You
can&#39;t raise a city into the clouds, but you can create a blog slice &amp; dice
system in a few days that will change your life forever. It&#39;s a perfect case of
the releasing built-up potential that I&#39;m always talking about.

I put a link to the one long journal file on this site&#39;s homepage. But now I
need links to the sliced &amp; diced version. I need to create a blog index page...

Alright! A big breakthrough. You can&#39;t put stuff without the date file naming
convention into \_posts. Instead, you put it in the repo root, but with
something like this:

```markdown
---
layout: post
title: &#34;Blog Index&#34;
slug: blog
---

This is a test.
```



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-26-post-6.md">FILE: ../pythonically/_posts/2022-04-26-post-6.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-26-post-6.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Turning Repo into nbdev Project&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: turning-repo-into-nbdev-project
permalink: /blog/turning-repo-into-nbdev-project/
---

Let&#39;s see how quickly you can get blogslicer in PyPi.org as an nbdev project.

Okay, I just:

- Created ~/github/blogslicer
- Created github repo
- Tied the 2 together and pushed
- Did nbdev_new
- Edited settings.ini
- Moved and renamed the notebook into repo
- Attempted nbdev_clean_nbs (didn&#39;t appear to work)
- Added notebook to repo and pushed

Okay, what next? Make the new one which is now named 00_core.py work on files
that are not in its own directory.

I added the various cells and comments that nbdev needs. nbdev_clean_nbs is now
doing its thing. This stuff is only now going to be published as a result of
this process working.

I should alter pythonically.com to not use index.md as the journal or the
homepage. Instead, it will be journal.md and I will put another index.md in
location. I will have to quit out of vim where I have all my site journals
loaded and edit the all.sh file with the new filename. Don&#39;t do this with ALL
your sites yet. Just start with pythonically.com and see how it goes.



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-26-post-5.md">FILE: ../pythonically/_posts/2022-04-26-post-5.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-26-post-5.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Using Blog Titles for Filenames&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: using-blog-titles-for-filenames
permalink: /blog/using-blog-titles-for-filenames/
---

Made a lot of good progress yesterday on the blog slice &amp; dice system. Just
have to get that title stuff down. Okay, got it done. There are little
concessions here and there because I&#39;m keeping my blogging format mostly
intact.

```python
import dateutil
from slugify import slugify
from IPython.display import display, Markdown


h1 = lambda text: display(Markdown(f&#34;# {text}&#34;))
h2 = lambda text: display(Markdown(f&#34;## {text}&#34;))
h3 = lambda text: display(Markdown(f&#34;### {text}&#34;))

site_base = &#34;https://pythonically.com&#34;
slicer = &#34;-&#34; * 80

dates = []
counter = -1
date_next = False
with open(&#34;./index.md&#34;, &#34;r&#34;) as fh:
    for line in fh:
        line = line.rstrip()
        if date_next:
            adate = line[3:]
            date_next = False
            adatetime = dateutil.parser.parse(adate).date()
            dates.append(adatetime)
            date_next = False
        if line == slicer:
            date_next = True
            counter = counter + 1
dates.reverse()

h1(f&#34;There Are {counter} Posts:&#34;)

table = []
at_top = True
with open(&#34;./index.md&#34;, &#34;r&#34;) as fh:
    for i, line in enumerate(fh):
        line = line.rstrip()
        if line == slicer:
            if at_top:
                at_top = False
                table = []
                continue
            adatetime = dates[counter - 1]
            filename = f&#34;./_posts/{adatetime}-post-{counter}.md&#34;
            h3(f&#34;FILE: {filename}&#34;)
            with open(filename, &#34;w&#34;) as fw:
                title = f&#34;Post {counter}&#34;
                if table[0] == slicer:
                    table = table[1:]
                maybe = table[1]
                has_title = False
                if table and maybe and maybe[0] == &#34;#&#34;:
                    title = maybe[maybe.find(&#34; &#34;) + 1 :]
                    title = slugify(title)
                    has_title = True
                top = []
                top.append(&#34;---\n&#34;)
                top.append(&#34;layout: post\n&#34;)
                top.append(f&#39;title: &#34;{title}&#34;\n&#39;)
                top.append(&#34;categories: blog\n&#34;)
                slug = title.lower().replace(&#34; &#34;, &#34;-&#34;)
                top.append(f&#34;slug: {slug}\n&#34;)
                top.append(&#34;---\n&#34;)
                top.append(&#34;\n&#34;)
                top_chop = 2
                if has_title:
                    top_chop = 3
                table = [f&#34;{x}\n&#34; for x in table[top_chop:]]
                table = top + table
                # display(Markdown(&#39;&#39;.join(table)))
                print(&#34;&#34;.join(table))
                fw.writelines(table)
            counter = counter - 1
            table = []
        table.append(line)
```



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-25-post-4.md">FILE: ../pythonically/_posts/2022-04-25-post-4.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-25-post-4.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Slicing &amp; Dicing Single File to Jekyll Blog Posts&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: slicing-dicing-single-file-to-jekyll-blog-posts
permalink: /blog/slicing-dicing-single-file-to-jekyll-blog-posts/
---

I pushed out a few livestreams yesterday slice and dicing these single long
journal files into smaller separate files. I did it under the pressure of
livestreaming and didn&#39;t quite bring it to completion. I need to do a wee bit
more exercise in clear thinking. I did a pretty good job of a rough first pass,
but that&#39;s how bugs get in. Rough first pass needs a sort of clarity
superimposed on it afterwards. You can&#39;t ***always*** work like Roomba, just
backing up, turning a little and retrying. Sometimes you need to look at the
entire situation and make higher-order determinations.

One of the ways to do this is to be very precise about the debugging messages
that you output while the script runs. This output is side-effects of the
script. The functional result of running the script is the same whether the
print statement output is shown or not, so the print statement is purely for me
during the running of the script. Make it work for me better.

Get your in-Notebook headlines!

Okay, headlines are in. Putting in headlines makes everything start to fall in
place. The hierarchy implied by headlines, especially h1, h2 &amp; h3 are highly
clarifying.

Pshwew! That took some wrangling. It turned out that there&#39;s some sort of
nuances keeping the Title from working as URLs, or at least easily. I
pre-process the titles into slugs and use the slugs in the frontmatter and
\_config.yml file.

I&#39;ll have to maybe do another video or publish the code or something. Suffice
to say I have the &#34;success assured&#34; moment now under my belt. I have just a bit
more pushing to do to hit this project home.

I need to have a more sensible default filename. Right now the URLs would
change every time I sliced &amp; diced the journal because the counter goes UP as
it goes through the file, but the fine is in reverse chronological notation.

What are my blogging conventions?

The page slicer token is always 80 hyphens. That&#39;s such a clean &#34;cut&#34;.

There needs to be a slicer token at the bottom of the document indicating the
&#34;last&#34; or perhaps the &#34;first&#34; post, depending on how you think about it.

Okay, done. I had to start the counter from -1 to get it right. It counts-up
and then counts-down. The URLs will never change so long as the headline never
changes. But these things have no headlines. Fix that, but make them optional.
You have a system now that creates a very nice default URL /blog/post-n/



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-24-post-3.md">FILE: ../pythonically/_posts/2022-04-24-post-3.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-24-post-3.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;Hello World&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: hello-world
permalink: /blog/hello-world/
---

Hello World! Practicing Jekyll blogging.



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-23-post-2.md">FILE: ../pythonically/_posts/2022-04-23-post-2.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-23-post-2.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;How To Control URLs and Links in Jekyll&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: how-to-control-urls-and-links-in-jekyll
permalink: /blog/how-to-control-urls-and-links-in-jekyll/
---

We are blogging using just a plain old text-file which currently becomes one
long file on pythonically.com. On my last video I got Jekyll&#39;s default blog
post system working. Jekyll is a static site publishing system built into
Github. The feature is called Github pages.

We changed our theme of Github Pages (through Github.com / Settings / Pages)

We did a git pull.

That got us our \_config.yml file.

I&#39;m following the instructions on this fine article:
https://www.digitalocean.com/community/tutorials/how-to-control-urls-and-links-in-jekyll

I&#39;m waiting for the Jekyll changes to propagate.

Success!



</pre>
</div>
</div>

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="FILE:-../pythonically/_posts/2022-04-23-post-1.md">FILE: ../pythonically/_posts/2022-04-23-post-1.md<a class="anchor-link" href="#FILE:-../pythonically/_posts/2022-04-23-post-1.md"> </a></h3>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>---
layout: post
title: &#34;My First Jekyll Blog Post&#34;
author: &#34;Mike Levin&#34;
categories: blog
slug: my-first-jekyll-blog-post
permalink: /blog/my-first-jekyll-blog-post/
---

Hello World! Each of these Github Pages sites starts out as a journal like
this.

### APIs in Math vs. APIs in Python

I think out loud regarding why I&#39;m not a &#34;math person&#34; even though by all
rights I should be. I realize I&#39;m hyper-literal in my internalization and
application of &#34;da rulez&#34;. High school algebra in particular limits my
capability for the sort of abstract thought required for higher mathematics.

{% include youtubePlayer.html id=&#34;TCNpKUj53fo&#34; %}

I hit the point home with this video where I show a division operator in Python
(/) being overwritten by pathlib and the default Python slice API being
overwritten by Pandas.

{% include youtubePlayer.html id=&#34;FDYRQbw6X4M&#34; %}

If I&#39;m going to do better practicing what I preach, I can&#39;t have these long
journal pages as my main homepages of these various sites. So, I need to think
about slice &amp; dicing the sites... and releasing the potential of the tools I&#39;m
using, doing as little re-invention as possible UNLESS it&#39;s absolutely called
for... in which case it wouldn&#39;t really be re-invention.

I have done a WordPress to Jekyll import (MikeLev.in) and I can look at it as
an example... but why? Go for the ideal if it exists. See how Jekyll WANTS you
to blog. Lean into the strengths of the tool.

- Keep your original data in whatever format works best for you.
  - For me, that&#39;s one long journal-like text-file (for life)
- Focus on the &#34;transforms&#34;
  - You can always adjust your transforms
  - You don&#39;t really even rely on Jekyll
  - Keep yourself platform-independent
- The platforms you&#39;re not independent of &#34;always&#34; include:
  - Linux
  - Python
  - vim
  - git

We are NOT migrating a blog. We&#39;re starting from scratch, so this page:
https://jekyllrb.com/docs/posts/

I put a file in location to test the system.

https://pythonically.com/2022/04/23/My-First-Jekyll-Blog-Post.html

Great success.

There&#39;s much still to learn, especially about controlling that URL (categories
&amp; tags)... but this is a &#34;success assured&#34; moment. All I need to do is add a
slice &amp; dice process to my master publishing script.

Okay, wow, so I got the title logic in. Now slap some headlines on these blog
posts. A few with, a few without.


</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

</div>


